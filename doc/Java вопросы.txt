1. http://becomejavasenior.com/blog/2015/07/01/327-interview-questions-java-developer/

2. Да, кстати к заголовку поста, синьёров спрашивают по сути тоже что и мидлов и джуниоров: Java Core, коллекции, мапинги в хибернейт, скоупы бинов в спринге, 
пару задачек на агрегацию SQL, но в добавок особенно уже начинают расспрашивать низкоуровневую жесть: про то как работает Garbage Collector, 
как исправлять проблемы на сервере через jconsole, и особенно жёстко Concurrency — что такое ThreadLocal, volatile. 
Проблема в том что конкаренси это такая жёсткая тема которую ну просто невозможно изучить не поработав на проекте с нею. 
Вопросы по алгоритмам почти всегда — на знания деревьев и их обход.

3.http://java67.blogspot.co.uk/2013/07/15-advanced-core-java-interview-questions-answers-senior-experienced-5-6-years-programmers-developers.html
тут глянуть



ВОПРОСЫ

1.
Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?
 50 слов if,else,abstract,do,void ...  
null,true,false  - это литералы, не ключевые слова и не зарезервированные
const,goto - не используются


2 Из каких символов может состоять имя переменной (корректный идентификатор)?
Строчные,прописные буквы английского алфавита, $,_ цифры, только не первая


3 Что значит слово “инициализация”?
Создание,активация.
int i; -объявление
i=10; инициализация


4 На какие основные группы можно поделить типы данных?
Примитивные и ссыллочные.


5 Какие примитивные типы вы знаете? 
boolean,int,short,float,double,byte,long,char
http://www.helloworld.ru/texts/comp/lang/java/java/04.htm


6 Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?
Неявное, когда длина нового типа больше или равна, и явное когда наоборот.
Неявное byte->short->int->long
float->double
int->char

int i = 13;
byte b = i; // Компилятор не разрешит это выражение
У int под целую часть уделено больше битов чем у float под целую, поэтому может потеряться точность при преобразовании int -> float
long в double такие же проблемы
boolean ни во что не преобразуется и ничто нельзя сделать boolean

при сложении, вычитании,умножении, делении разных чисел результат всегда большое из 2-х
например int+double = double

7 Какими значениями инициализируются переменные по умолчанию?
null,false, 0,0f,0d
'\u0000' - это char по умолчанию, символ null

8 Как передается значение переменной (по ссылке/значению)?
 В случае, когда аргумент – примитивный тип, передача по значению означает то, что метод не может изменить оригинальное значение. 
Когда же аргумент – ссылка на объект, создается локальная копия ссылки, которая указывает на тот же самый объект, 
при изменении которой оригинальное состояние объекта остается неизменным. (прим. редактора: верно - ВСЕ ПАРАМЕТРЫ В JAVA ПЕРЕДАЮТСЯ ПО ЗНАЧЕНИЮ.
 Если параметр — ссылка на объект, то ЗНАЧЕНИЕМ является ЗНАЧЕНИЕ самой ссылки, а не значение разнообразных полей в объекте, 
коих может быть великое множество, как по количеству, так и по разнообразию типов).

9 Что вы знаете о функции main, какие обязательные условия ее определения?
Точка входа в программу.
public static void main(String[] args){
}



10 Какие логические операции и операторы вы знаете?
&,|,&&,||,^(XOR - исключающее или),!,&=,|=,==,!=,?:
http://developer.alexanderklimov.ru/android/java/logic_operators.php

A+=5;
A&=B;



11 В чем разница краткой и полной схемы записи логических операторов?
&& || ппроверяет только один операнд если выполняется 
int mouse; // число мышек
int weight; // вес кота в граммах
mouse = 5;
weight = 4500;
if (mouse != 0 & weight / mouse < 1000) {
	textViewInfo.setText("Можно кормить кота");
}



12 Что такое таблица истинности? Просто битовые рез-ты лог. операций.

13 Что такое тернарный оператор выбора? ?:
String res = a==b ? "OK" : "NOT OK"

14 Какие унарные операции вы знаете?   http://javapd.blogspot.com/2008/04/2-4.html
	++ -- + - ! ~ ()
Инкремент (увеличение значения на 1) и декремент (уменьшение значения на 1): ++ и --
В предыдущих примерах операторы находились перед переменной. Они могут находиться и после неё. И ++x, и x++ дают один и тот же результат, сохраняемый в x. 
Но значение всего выражения отличается. Например, 

если y = x++, то значение y равно исходному значению x. Если же y = ++x, то значение y на единицу больше, чем исходное значение x. 
В обоих случаях значение x увеличивается на 1.

Унарный плюс и минус: + и -  Это x = -3;

Поразрядное инвертирование (побитовое унарное отрицание): ~
Логическое дополнение: !
Приведение типа: ( )
т.к. в Java левый бит отвечает за знак числа, 1-это минус,0-плюс



15 Какая арифметическая операция выполняется при побитовом сдвиге вправо/влево?
влево - *2 в степени n , вправо для пол. чисел /2 в степени n
http://developer.alexanderklimov.ru/android/java/bitwise.php

x<<8  x>>2
x*2(8)

16 Какова роль и правила написания оператора выбора?
switch(5){
default: System.out.print(0);
case 1: System.out.print(1); break;
case 4: System.out.print(4);
case 2: System.out.print(2);
} 
Результат 01;


17 Какие циклы вы знаете, в чем их отличия?
for,while
do {
    i++;
    System.out.print(i + " ");
} while (i < 5);

18 Что такое “итерация цикла”? 1 проход цикла.

19 Какие параметры имеет цикл for, можно ли их не задать?
   for (инициализация; условие; итерация) {
      //тело цикла, т. е. действия повторяемые циклично
   }
А можно вообще все три части оператора оставить пустыми:
for( ; ;) {
    //...  это бесконечный цикл
}


20 Какой оператор используется для немедленной остановки цикла? 
break;

21 Какой оператор используется для перехода к следующей итерации цикла?
  continue;

22 Что такое массив?
Массив — это конечная последовательность упорядоченных элементов одного типа, доступ к каждому элементу в которой осуществляется по его индексу.

Размер или длина массива — это общее количество элементов в массиве. Размер массива задаётся при создании массива и не может быть изменён в дальнейшем, т. е. нельзя убрать элементы из массива или добавить их туда, 
но можно в существующие элементы присвоить новые значения.

Индекс начального элемента — 0, следующего за ним — 1 и т. д. Индекс последнего элемента в массиве — на единицу меньше, чем размер массива.

int[][] ddd2 = {{1,2}, {1,2,3,4,5}, {1,2,3}}; инициализация двумерного массива
int[][][][][] d5; //Пятимерный
Но можно указать только размер первого уровня:
int[][] dd2 =  int[5][]; /* Матрица из 5 строк. Сколько элементов будет в каждой строке пока не известно. */


23 Какие виды массивов вы знаете?
Одномерные,многомерные

24 Что вы знаете о классах оболочках?
Byte,Short,Long .... Нужны для того чтобы возможно было делать коллекции из примит. типов

25 Что такое автоупаковка (boxing/unboxing)?
Автоупаковка (autoboxing) — это процесс автоматической инкапсуляции данных простого типа, такого как int или double, в эквивалентную ему оболочку типа, 
как только понадобится объект этого типа. При этом нет необходимости в явном создании объекта нужного типа. Автораспаковка (auto-unboxing)
 — это процесс автоматического извлечения из упакованного объекта значения, когда оно потребуется. Вызовы методов, таких как intValue() и doubleValue(), 
становятся ненужными.









ООП (оглавление)

26 Назовите принципы ООП и расскажите о каждом.
Абстракция
в объектно-ориентированном программировании это придание объекту характеристик, которые отличают его от всех других объектов, четко определяя его концептуальные границы. 
Основная идея состоит в том, чтобы отделить способ использования составных объектов данных от деталей их реализации в виде более простых объектов, подобно тому, 
как функциональная абстракция разделяет способ использования функции и деталей её реализации в терминах более примитивных функций, таким образом, 
данные обрабатываются функцией высокого уровня с помощью вызова функций низкого уровня.
 Такой подход является основой объектно-ориентированного программирования. Это позволяет работать с объектами, не вдаваясь в особенности их реализации.
Инкапсуляция
Соединить данные и методы и работать с классом через интерфейсы
Интерфейсы, а что внутри скрыто.

Наследование - понятно

Полиморфизм - Один интерфейс, множество реализаций


27 Дайте определение понятию “класс”.
Класс описывает содержание и поведение некой совокупности данных и действий над этими данными. Объявление класса производится с помощью ключевого слова class.


28 Что такое поле/атрибут класса?
 переменная класса


29 Как правильно организовать доступ к полям класса?
   Через get set 


30 Дайте определение понятию “конструктор”.
Конструктор - это специальный метод, который вызывается при создании нового объекта. 
Не всегда удобно инициализировать все переменные класса при создании его экземпляра. Иногда проще, чтобы какие-то значения были бы созданы по умолчанию при создании объекта. 
По сути конструктор нужен для автоматической инициализации переменных.
Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на 
метод без возвращаемого значения.
Конструктор не может быть abstract, static, final, native или synchronized.



31. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?
// конструктор копии
        public Person(Person other) {
            this(other.getAge(), other.getName());
        }



32. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
Как я уже говорил, в Java существуют четыре модификатора доступа: public, private, protected и отсутствие модификатора (он же модификатор по умолчанию). К невложенным классам и интерфейсам применимы только два из них: public и модификатор по умолчанию. К методам и полям класса применим весь набор.

Если метод или поле имеют модификатор public, то они потенциально доступны всей вселенной.
Если метод или поле имеют модификатор доступа private, то они доступны только в рамках класса. Такие члены класса не наследуются, поэтому их невозомжно заместить в подклассах. Помните об этом.
Если метод или поле имеют модификатор доступа по умолчанию, то они доступны только в рамках пакета.
Если метод или поле имеют модификатор доступа protected, то они, прежде всего, доступны самому классу и его наследникам. Кроме того, доступ к этим членам класса могут получить их собратья по пакету.



33. Расскажите об особенностях класса с единственным закрытым (private) конструктором.
Private конструктор - можно создать Экземпляр, только из статического метода этого класса. Как правило это Singleton

34. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?
this - обращается к экземпляру тек. класса, super - к текущему экземпляру род. класса.
Это нестатические переменные,если они в конструкторе , то только первой строкой соответственно в конструкторе может быть только this() или super() 
Теперь мы знаем как использовать ключевые слова super и this и понимаем для чего они нужны. Но есть ещё один вариант использования этих ключевых слов, о котором я не сказал — во Внутренних классах, 
где с их помощью очень удобно ссылаться на внешний класс, 
используя форму записи Outer.this для его текущего экземпляра и Outer.super — для его родителя. Не забудьте вместо Outer подставить имя внешнего класса.
Нет, переменной this нельзя присвоить новое значение, потому что она объявлена как final. Можете попробовать сделать это в IDE — получите ошибку компиляции «нельзя присвоить новое значение переменной this — она объявлена как final».


35. Дайте определение понятию “метод”.
Метод — это именованный обособленный блок кода. 
С методом можно выполнить три операции. Объявить — описать, что такой метод есть, однако не расписывать его содержимое, т.е. тело; определить — описать метод с его структурой, т.е. с его телом; вызвать, т.е. запустить этот метод на выполнение.
Объявление метода состоит из двух частей: заголовка метода и его тела. 
В заголовке метода указываются его модификаторы, имя метода и в скобках его параметры (аргументы). Тело метода располагается между двумя фигурными скобками и является блоком кода.

36. Что такое сигнатура метода?
Сигнатура метода состоит из имени метода и числа и типа формальных параметров метода. Класс не может объявлять два методы с одинаковой сигнатурой, или происходит ошибка во время компиляции.


37. Какие методы называются перегруженными?
Метод называется перегруженным, если существует несколько его версий с одним и тем же именем, но с различным списком параметров. Перегрузка реализует «раннее связывние».
 Перегрузка может ограничиваться одним классом. Методы с одинаковыми именами, но с различающимися списком параметров и возвращаемыми значениями могут находиться в разных классах одной цепочки наследования и также 
будут являться перегруженными. Если в последнем случае списки параметров совпадают, то имеет место другой механизм – переопре­деление метода.
Статические методы могут перегружаться нестатическими и наоборот – без ограничений.
При вызове перегруженных методов следует избегать ситуаций, когда компилятор будет не в состоянии выбрать тот или иной метод.

38. Могут ли нестатические методы перегрузить статические?
Могут

39. Расскажите о переопределение методов. 
Наследник переопределяет метод предка.
 

40. Может ли метод принимать разное количество параметров (аргументы переменной длины)?
Когда вы указываете параметр vararg, то базовым типом может быть любой тип: примитивный или нет.
Чтобы объявить такой параметр, вы пишите тип, потом три точки, пробел, затем имя массива, который будет использоваться в рамках метода: void f (int... a). Можно также разделить тип, три точки и идентифкаторы пробелами, так: void f(int ... a). Внимательно следите за точками. Авторы экзамена любят переносить их за идентификатор. Такой подход не работает.
В метод могут передаваться другие параметры, но в этом случае параметр vararg должен быть последним: void f (double x, int... a)
В методе может быть один и только один vararg параметр.
Нельзя вместо vararg параметра давать массив типа new int[] {1, 2 ,3} - - ошибка
static void doSomething(int x, int... values) {
    System.out.println("OK 2");
}
doSomething(1); сработает, vararg-параметр является всего лишь синтаксическим сахаром и воспринимается компилятором как ссылка на массив, поэтому никаких проблем не возникает.



41. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
 При Наследовании ( с учитыванием вышесказанного ) для Классов и полей возможно как раширение так и сужение границ доступа,
 для методов же нельзя делать более ограниченный доступ, чем у перекрываемого метода, а расширять можно,но: Private методы видны только внутри класса, для потомков они не видны. Поэтому их и расширить нельзя.


42. Как получить доступ к переопределенным методам родительского класса?
Используя super


43. Какие преобразования называются нисходящими и восходящими?
public class CastingExample {
    public static void main(String args[]) {
        Monster monster1 = new Dragon(); неявное восходящее
        Monster monster2 = new Orc();    неявное восходящее
 
        ((Dragon)monster1).say();        явное нисходящее
        ((Orc)monster2).say();           явное нисходящее 
    }
}


44. Чем отличается переопределение от перегрузки?
  Переопределение - при наследовании. Перегрузка - одинаковое имя,разный набор параметров.


45. Где можно инициилизировать статические/нестатические поля?
   Статические как поля класса.Во внутреннем статическом классе. В статик блоке.В интерфейсах.
   Нестатические - где угодно. 

   


46. Зачем нужен оператор instanceof?
Используя оператор instanceof, можно узнать, от какого класса произошел объект.
Старайтесь как можно реже использовать оператор instanceOf. Это один из самых медленных java операторов и подходить к его использованию нужно осторожно. 




47. Зачем нужны и какие бывают блоки инициализации?
Статические блоки - понятно, инициализируем стат данные при загрузке класса.
Нестатические
class Bar {
	{
		System.out.println("Bar: новый экземпляр");
	}
}
Они позволяют проводить инициализацию объектов вне зависимости от того, какой конструктор был вызван или, например, вести журналирование
Такой метод инициализации весьма полезен для анонимных внутренних классов, которые конструкторов иметь не могут. Кроме того, вопреки ограничению синтаксиса Java, используя их, мы можем элегантно инициализировать коллекцию


48. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
Блок инициализации предка, потом потомка, конструктор предка потом потомка


49. Где и для чего используется модификатор abstract?
Модификатор abstract применяется только для классов и методов.
Абстрактный класс не может быть инстанциирован, то есть нельзя вызвать конструктор для создания его объекта.
Абстрактные классы перекладывают имплементацию методов на "плечи" своих подклассов.



50. Можно ли объявить метод абстрактым и статическим одновременно?
нет конечно.



51.  Что означает ключевое поле static?
Переменные экземпляров, объявленные как static, по существу являются глобальными переменными. При объявлении объектов их класса программа не создает никаких копий переменной static.
 Вместо этого все экземпляры класса совместно используют одну и ту же статическую переменную.
Когда член класса объявлен как static (статический), он доступен до создания каких-либо объектов его класса и без ссылки на какой-либо объект. Статическими могут быть объявлены как методы, так и переменные.

Так же существует static блок, который выполняется при загрузке класса. 
И немного про static-блоки, init-блоки и конструкторы и как они вызываются учитывая иерархию:
static-блок вызывается при загрузке класса, поэтому static-блок super-класса будет вызван раньше, чем static-блок наследника.
Вызов других конструкций следующий (при создании экземпляра): init-блок super-класса, конструктор super-класса, init-блок наследника, конструктор наследника. Т.к. init-блок всегда выполняется перед конструктором, а перед вызовом контруктора наследника всегда вызывается конструктор super-класса.
init/static блоки в рамках одного класса вызываются в последовательности определения.



52. К каким конструкциям Java применим модификатор static?
К методу.
К внутреннему классу.
К полю.
К импортируемым классам (с 5-ой java) - import static java.lang.Math.PI; Доступны все static методы класса PI

53. Что будет, если в static блоке кода возникнет исключительная ситуация?
Статичный блок НЕ может пробросить перехваченные исключения, но может выбросить не перехваченные.
В таком случае возникнет «Exception Initializer Error». На практике, любое исключение возникшее во время выполнения и инициализации статических полей, будет завёрнуто Java в эту ошибку.
Если в явном виде написать любое исключение в static-блоке, то компилятор не скомпилирует исходники. Это все от того, что компилятор умный. 

static{ статик блок
}
{ инит блок
}


54. Можно ли перегрузить static метод?
Статические методы могут перегружаться нестатическими и наоборот – без ограничений.
А вот в переопределении статического метода смысла нет.
Другим важным моментом является то, что вы НЕ можете переопределять (Override) статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), 
т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass) вместо переопределения. Это явление известно как сокрытие методов (hiding methods).
 Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной.
 В отличие от переопределения, такие методы не будут выполнены во время работы программы. Рассмотрим пример:



55. Что такое статический класс, какие особенности его использования?
Статическим классом может быть только внутренний клас(определение класса размещается внутри другого класса). 
В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса.
 Внутри статического внутреннего класса такой ссылки нет.
То есть:
Для создания объекта статического внутреннего класса не нужен объект внешнего класса.
Из объекта статического вложенного класса нельзя обращаться к нестатическим членам внешнего класса напрямую
И еще обычные внутренние классы не могут содержать статические методы и члены.
Зачем вообще нужны внутренние классы?
Каждый внутренний класс способен независимо  наследовать определенную реализ-ю.Таким образом внутренний класс не ограничен при наследовании в ситуациях, когда внешний класс уже наследует реализацию. 
То есть это как бы вариант решения проблемы множественного наследования.

56 Какие особенности инициализации final static переменных?
Final переменные, объявленные как static, должны быть проинициализированы при объявлении или в блоке инициализации, также объявленном как static. В противном случае,получится ошибка компиляции.


57 Как влияет модификатор static на класс/метод/поле?
метод,поле - понятно  в целом
Класс:
Объявить статическим также можно и класс, за исключением классов верхнего уровня. Такие классы известны как «вложенные статические классы» (nested static class). 
Они бывают полезными для представления улучшенных связей. Яркий пример вложенного статического класса — HashMap.Entry, который предоставляет структуру данных внутри HashMap. 
Стоит заметить, также как и любой другой внутренний класс, вложенные классы находятся в отдельном файле .class. Таким образом, если вы объявили пять вложенных классов в вашем главном классе, у вас будет 6 файлов с расширением .class. 
Ещё одним примером использования является объявление собственного компаратора (Comparator), например компаратор по возрасту (AgeComparator) в классе сотрудники (Employee). 



2) В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe) в Java. На практике это одна из наиболее частых причин возникновения проблем связанных с безопасностью мультипоточного программирования.
 Учитывая что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите — «залочивании» классом. 
Поэтому при использовании статических переменных, убедитесь, что они должным образом синхронизированы (synchronized), во избежание проблем, например таких как «состояние гонки» (race condition). 



58 О чем говорит ключевое слово final?
Разрешается применять модификатор final к полям, аргументам методов и локальным переменным. В случае примитивных типов будет запрещено любое изменение значения переменной, кромее ее инициализации. 
Тут следует помнить, что моментом инициализации локальных переменных считается первое присваивание им значения в рамках метода. До этого переменную использовать нельзя: получите ошибку при компиляции. 
Помеченное final поле также придется явным образом инициализировать. Это можно сделать либо непосредственно при объявлении, в инициализационном блоке, либо в конструкторе того класса, в котором оно объявлено. 
Оставлять инициализацию final полей на совести наследников не разрешается. В случае ссылок модификатор final запретит переприсваивать ссылку. Сам объект, на который ссылка указывает, все еще можно изменять: 
вызывать изменяющие его состояния методы, присваивать полям новое значение и так далее.
Важно помнить, что к локальным переменным неприменимы никакие модификаторы, кроме final. Поэтому, если вы видите в объявлении локальной переменной что-то вроде private int a, то можно смело говорить, что это не скомпилируется.

Может быть применено к полям, методам или классам. В зависимости к какой сущности приложено данное ключевое слово - будет и различный смысл в его применении.
Для класса. Класс помеченный при помощи final не может иметь наследников.
Для метода. Метод помеченный при помощи final не может быть переопределен в классах наследниках.
Для поля. Поле помеченное при помощи слова final не может изменить свое значение после инициализации (инициализируется либо при описании, либо в конструкторе/статическом блоке).
Значение локальных переменных, а так же параметров метода помеченных при помощи слова final не могут быть изменены после присвоения.



59. Дайте определение понятию “интерфейс”. Интерфейс - это Договор.
Интерфейсы в Java во многом напоминают классы, но могут содержать только константы, сигнатуры методов и вложенные типы. В интерфейсах нет описания методов. 
Нельзя создать объект типа интерфейса (но можно использовать в качестве типа — интерфейсные ссылки, об этом позже) 
— интерфейсы могут только реализовываться некоторым классом или наследоваться другим интерфейсом. Объявление интерфейса очень похоже на объявление класса:

60. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). Все методы и переменные неявно объявляются как public.


61. Почему нельзя объявить метод интерфейса с модификатором final или static?
final - глупость. поскольку методы интерфейсы предназначены чтобы их определяли.
Static - статические методы не переопределяются. Они должны быть реализованы.
protected и private тоже нельзя. ибо все public должно быть.


62. Какие типы классов бывают в java (вложенные… и.т.д.)
Обычные классы (Top level classes) -  public и default (сразу оговорюсь, что под модификатором доступа default мы будем подразумевать отсутствие модификатора доступа вообще).

Интерфейсы (Interfaces)

Перечисления (Enum)

Статические вложенные классы (Static nested classes)
Есть возможность обращения к внутренним статическим полям и методам класса обертки.

Внутренние статические интерфейсы могут содерать только статические методы.

Внутренние классы-члены (Member inner classes)
Есть возможность обращения к внутренним полям и методам класса обертки.
Не может иметь статических объявлений.
Нельзя объявить таким образом интерфейс. А если его объявить без идентификатора static, то он автоматически будет добавлен.
Внутри такого класса нельзя объявить перечисления.
Если нужно явно получить this внешнего класса - OuterClass.this

Локальный класс (Local inner classes)
Локальные классы — это классы, объявленные в блоке операторов между фигурными скобками. Например, локальные классы, объявленные в теле метода.
Видны только в пределах блока, в котором объявлены.
Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
Не могут иметь внутри себя статических объявлений (полей, методов, классов).
Имеют доступ к полям и методам обрамляющего класса.
Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final.

Анонимные классы (Anonymous inner classes)
Локальный класс без имени - это анонимный класс.




63. Что вы знаете о вложенных классах, зачем они используются? Классификация, варианты использования, о нарушении инкапсуляции.
Вот некоторые причины использования вложенных классов:
Это хороший способ группировки классов, которые используются только в одном месте: если класс полезен только для одного другого класса, то логично будет держать их вместе. 
Вложение таких вспомогательных классов делает код более удобным.

Инкапсуляция: допустим, есть два класса A и B, классу B требуется доступ к свойству класса A, которое может быть приватным. Вложение класса B в класс A решит эту проблему, 
более того сам класс B можно скрыть от внешнего использования.

Улучшение читаемости и обслуживаемости кода: вложение малых классов в более высокоуровневые классы позволяет хранить код там, где он используется.

Это аналог множественного наследования.


64. Каким образом из вложенного класса получить досуп к полю внешнего класса?
OuterClass.StaticNestedClass


65. Какие особенности создания вложенных классов: простых и статических.
Статический класс можно создать не создавая объект внешнего класса, внутренний нестатический - нельзя.





66. В чем разница вложенных и внутренних классов?
Вложенные классы делятся на два вида: статические и не статические. Вложенные классы, объявленные как статические называются вложенными статическими (static nested classes). 
Не статические называются внутренними (inner classes).
Вложенные классы — элементы содержащего их класса. Не статические классы имеют доступ к полям содержащего класса, даже если они объявлены как private.
Статические — не имеют доступ к членам внешнего класса. Как и другие поля класса, вложенные классы могут быть объявлены как private, public, protected, или package private.

Внутренние (не статические) классы, как переменные и методы связаны с объектом внешнего класса. Внутренние классы так же имеют прямой доступ к полям внешнего класса. 
Такие классы не могут содержать в себе статические методы и поля. Внутренние классы не могут существовать без экземпляра внешнего. Для создания объекта:
OuterClass.InnerClass innerObject = outerObject.new InnerClass();


67. Какие классы называются анонимными?
Анонимные классы позволяют сделать ваш код более кратким. Анонимные классы позволяют одновременно объявить класс и создать его экземпляр.
Анонимные классы, в отличие от локальных, не имеют имени. Используйте анонимные классы, если локальный класс нужен вам единожды.
В отличие от объявления обычных классов, объявление анонимных классов происходит внутри выражения.


68. Каким образом можно обратиться к локальной переменной метода из анонимного класса, объявленного в теле этого метода? Есть ли каке-нибудь ограничения для такой переменной?
Анонимный класс не имеет доступ локальным переменным области, в которой он определен, если они не финальные (final) или неизменяемые (effectively final).


69. Как связан любой пользовательский класс с классом Object?
Класс Object - это базовый класс. Для каждого класса Object - супер класс. Все объекты, включая массивы имплементируют методы этого класса.

70. Расскажите про каждый из методов класса Object.
boolean equals(Object o)
void finalize() // вызывается сборщиком мусора, когда gc определил, что ссылок на объект больше нет.
Class<?> getClass() //возвращает в рантайме класс данного объекта.
int hashCode()
String toString()
Object clone() // create and returns a copy of this object.

Вызываются либо в блоке synchronized либо в методе synchronized 
wait() приостанавливает выполнение потока на котором был вызван.Освобождает блокировку,т.е другой поток может захватить монитор
notify() случайно выбырает поток из находящихся в состоянии wait и переводит его в состояние run. 
notifyAll() переводит все потоки находящиеся в состоянии wait в состоянии run.

void wait(long timeout) // Приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не исчет указанный промежуток времени.
void wait(long timeout, int nanos) // nanos - дополнительное время в наносекундах.

71. Что такое метод equals(). Чем он отличается от операции ==.
Метод, определенный в Object, который служит для сравнение объектов на равенство. При сравнение объектов при помощи == идет сравнение по ссылкам. 
При сравнении по equals идет сравнение по состояниям объектов (реализация метода equals для нового созданного класса ложится на плечи разработчиков).
Причем равенство должно работать в обе стороны.
Должно выполняться условие транзитивности -> a=b и b=c, значит a=c
Для одних и тех же экземпляров результат работы метода должен быть всегда одинаков.


72 Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?
см предыдущий вопрос



73. Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?
hashCode()


74. В чем особенность работы методов hashCode и equals? Каким образом реализованы методы hashCode и equals в классе Object? Какие правила и соглашения существуют для реализации этих методов? Когда они применяются?
Этот метод используется для хэш таблиц, таких как HashMap. Контракт:
Когда метод hashCode() последовательно вызывают на одном и том же объекте, метод должен возвращать в этом случае одни и теже значения, при условии, что никакая информация, которая используется в equals() при сравнении не изменилась.
Возвращаемый хэш код может быть различным в различных запущенных приложениях.
Два объекта равные по equals() должны возвращать одинаковый hashCode().
Не обязательно, что объекты не равные по equals() должны возвращать разные hashCode().
В классе Object метод equals производит сравнение по ссылке, метод hashCode() генерироет hash при помощи нативного кода из адреса ссылки(или с помощью генератора случ. чисел).

75. Какой метод возвращает строковое представление объекта? 
toString()



76. Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?
Начнем с простого. Что будет, если переопределить equals, но не переопределить hashCode? Будем расуждать логически. Пусть у нас есть два равных с точки зрения equals объекта. Если не переопределить hashCode, 
то вероятность того, что эти два объекта попадут в одно подмножество в HashSet, – эта вероятность крайне низка. Ненулевая, но все же низкая. А это значит, что два равных с вашей точки зрения объекта попадут в HashSet 
с очень большой вероятностью. Если же эти объекты использовать в качестве ключей в HashMap (используя один объект как ключ,
 положить значение, используя другой – искать его), то значение, проассоциированное с ключом, найдено не будет. Опять-таки, с большой вероятностью. И это хуже всего. Если бы вероятность была 100% – ошибку искать было бы намного проще.
Новый ключ - такой же объект, но ссылка другая.



77. Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?
При подсчете hashCode необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid, например. Причем, если эти поля задействованы при вычислении hashCode, то нужно их задействовать и при выполнении equals.



78. Как вы думаете, будут ли какие-то проблемы, если у объекта, который используется в качестве ключа в hashMap изменится поле, которое участвует в определении hashCode?
Будут. Опять же будут проблемы связанные с хэш коллекциями. А именно, не сможем выбрать элемент из хэш-коллекции, его как будто и не будет.


79. Чем отличается абстрактый класс о интерфейса, в каких случаях что вы будете использовать?
Абстрактный класс это класс, который помечен как «abstract», он может содержать абстрактные методы, а может их и не содержать. 
Экземпляр абстрактного класса нельзя создать.
Класс, который наследуется от абстрактного класса может реализовывать абстрактные методы, а может и не реализовывать, тогда класс наследник должен быть тоже абстрактным.
 Также если класс наследник переопределяет реализованный в абстрактном классе родители метод, его можно переопределить с модификатором абстракт! Т.е отказаться от реализации. Соответственно данный класс должен быть 
также абстрактным также.

Что касается интерфейса, то в нем находятся только абстрактные методы и константы. При реализации интерфейса, класс обязан реализовать все методы интерфейса. Иначе класс должен быть помечен как абстрактный.
Интересный момент, интерфейс может содержать внутренние классы! И не абстрактные методы в них.

Что же использовать Интерфейс или Абстрактный класс?
Абстрактный класс используется когда нам нужна какая-то реализация по умолчанию. Интерфейс используется когда классу нужно указать конкретное поведение. 
Часто интерфейс и абстрактный класс комбинируют, т.е. имплементируют интерфейс в абстрактном классе, чтоб указать поведение и реализацию по умолчанию. 




80. Можно ли получить доступ к private переменным классам и если да, то каким образом?
Внутри класса
рефлексия(крайне не рекомендуется).
Вложенный класс имеет полный доступ ко всем членам содержащего его класса, в том числе к членам, объявленным как private.


81. Модификаторы. Назначение и варианты использования.
public, private, protected и отсутствие модификатора


82. Что такое volatile и transient? Для чего и в каких случаях можно было бы использовать default?
transient – Переменная помеченая словом transient не будет сериализоваться и соответственно при десериализации её значение будет установлено значением по умолчанию.
volatile - Определение переменной с ключевым словом volatile(«изменчивый») означает, что значение переменной будет изменяться несколькими потоками.
Это означает, что значение переменной будет "всегда читаться". Например, в многопоточных приложениях один поток прочёл значение a=1, передал управление другому потоку, который изменил значение на a=2, потом управление вернулось. 
Так вот, без volatile значение a у первого потока будет 1, с volatile - 2.
Применимы только для полей классов.
Нет, не константное. volatile как бы говорит компилятору, что значение переменной может в любой момент измениться из другого потока и даже из другой программы, а он этого и не заметит. 
Поэтому компилятор прекращает выполнять различную оптимизацию,
 связанную с этой переменной, (к примеру, помещение копии в регистры) и всегда читает ее значение из памяти.


83. Контексты использования модификаторов (класс/поле/метод)
----

84. Какой из модификаторов более строгий: protected или package-private?
package-private. Поле с package-private уровнем доступа будет видно только в данном пакете всем классам.Тогда как protected видно для наследников данного класса, а так же для классов находящихся в данном пакете.


85. Расширение модификаторов при наследовании, переопределение и сокрытие методов. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость? А если protected? А сузить видимость?
 При Наследовании ( с учитыванием вышесказанного ) для Классов и полей возможно как раширение так и сужение границ доступа,
 для методов же нельзя делать более ограниченный доступ, чем у перекрываемого метода, а расширять можно,но: Private методы видны только внутри класса, для потомков они не видны. Поэтому их и расширить нельзя.
Если подкласс определяет метод класса (static метод) с такой же сигнатурой как и метод в суперклассе, то метод в подклассе скрывает метод суперкласса.


86. Модификатор abstract и final для классов/методов
_________ было уже

87 Имеет ли смысл объявлять метод private final?
Нет, такой метод не виден для наследников, а значит не может быть ими переопределен.




88 Какие особенности инициализации final переменных?
Может быть применено к полям, методам или классам. В зависимости к какой сущности приложено данное ключевое слово - будет и различный смысл в его применении.
Для класса. Класс помеченный при помощи final не может иметь наследников.
Для метода. Метод помеченный при помощи final не может быть переопределен в классах наследниках.
Для поля. Поле помеченное при помощи слова final не может изменить свое значение после инициализации (инициализируется либо при описании, либо в конструкторе/статическом блоке).
Значение локальных переменных, а так же параметров метода помеченных при помощи слова final не могут быть изменены после присвоения.




89 Что будет, если единственный конструктор класса объявлен как final?
К конструктору не применимо ключевое слово final.


90. Расширение/сужение типов в аргументах переопределяемых методов в случае, если бы в Java список формальных параметров не входил бы в сигнатуру метода.
________________ Не понял вопрос


91. Что такое finalize? Зачем он нужен? Что Вы можете рассказать о сборщике мусора и алгоритмах его работы.
Метод из Object
void finalize() // вызывается сборщиком мусора, когда gc определил, что ссылок на объект больше нет.
Давайте начнём с того, как JVM использует память. В JVM память делится на два сегмента – Heap и Permanent Generation.
Permanent generation используется только JVM для хранения необходимых данных, в том числе метаданные о созданных объектах. При каждом создании объекта JVM будет «класть» некоторый набор данных в PG. Соответственно,
 чем больше вы создаете объектов разных типов, тем больше «жилого пространства» требуется в PG. 
Размер PG можно задать двумя параметрами JVM: -XX:PermSize – задаёт минимальный, или изначальный, размер PG, и -XX:MaxPermSize – задаёт максимальный размер. 
При запуске больших Java-приложений мы часто задаём одинаковые значения для этих параметров, так что PG создаётся сразу с размером «по-максимуму», что может увеличить производительность, 
так как изменение размера PG – дорогостоящая (трудоёмкая) операция. Определение одинаковых значений для этих двух параметров может избавить JVM от выполнения дополнительных операций, 
таких как проверки необходимости изменения размера PG и, естественно, непосредственного изменения. 

Heap – основной сегмент памяти, где хранятся все ваши объекты. Heap делится на два подсегмента, Old Generation и New Generation. New Generation в свою очередь делится на Eden и два сегмента Survivor.
Размер heap также можно указать параметрами. На диаграмме это Xms (минимум) и -Xmx (максимум). Дополнительные параметры контролируют размеры сегментов heap. Мы позднее посмотрим один из них, остальные за рамкой этого поста. 
При создании объекта, когда вы пишете что-то типа byte[] data = new byte[1024], этот объект создаётся в сегменте Eden. Новые объекты создаются в Eden. 
Кроме собственно данных для нашего массива байт здесь есть ещё ссылка (указатель) на эти данные. 
Дальнейшее объяснение упрощено. Когда вы хотите создать новый объект, но места в Eden уже нет, JVM проводит garbage collection, что значит, что JVM ищет в памяти все объекты, которые более не нужны, и избавляется от них. 

Garbage collection – это круто! Если вы когда-либо программировали на языках типа C или Objective-C, то вы знаете, что ручное управление памятью – вещь утомительная и порой вызывающая ошибки. 
Наличие JVM, которая автоматически позаботится о неиспользуемых объектах, делает разработку проще и сокращает время отладки. Если же вы никогда не писали на подобных языках, 
значит возьмите С и попробуйте написать программу, и ощутите, как ценно то, что предоставляется вашим языком совершенно бесплатно.


92 Почему метод clone объявлен как protected? Что необходимо для реализации клонирования?
метод clone() объявлен в Object как protected и чтобы его использовать надо переопределить.
Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.
 Пример далее показывает, как одновременно меняется поле у оригинального объекта и клона.
Нужно.чтобы класс имплементировал интерфейс Cloneable. Если есть implements Cloneable нужно переопрделить clone()



93.Знакомы ли Вам какие-либо паттерны проектирования?
  http://habrahabr.ru/post/210288/ - тут их кучча
  Синглтон - только 1 экземпляр класса
  Абстрактная фабрика - Создаю Абстрактную фабрику, от нее конкретную фабрику наследую, которая создает определ. классы. Подаю эту фабрику в метод, который в зависимости от типа фабрики создает нужные классы.
  Прототип - класс, который просто создает объект такого же класса. Аналог клонирования.
  Декоратор - Основная задача данного шаблона проектирования – это расширение функциональности объекта, не используя наследования. Следовательно, шаблон Декоратор необходимо использовать, когда требуется реализовать 
               много независимых расширений и не создавать множество подклассов, что может привести к неверной архитектуре и сложности системы. Суть в том, что в конструктор класса передается другой класс, который будем расширять. 
               Оба класса реализуют 1 интерфейс.
  Цепочка обязанностей - когда один класс делает что ему положено, потом вызывает другой класс, который делает свое дело, и так далее.


94.Напишите Singleton… А с ленивой загрузкой. А если он должен быть потоко-безопасным? А в каких случаях ленивая загрузка хуже?
public class Singleton {
	public static final Singleton INSTANCE = new Singleton();
} На мой взгляд это лучшее и простое решение.


public enum Singleton {
	INSTANCE;
}


Это лучшая реализация для обычных полей:
public class Singleton {
        private static volatile Singleton instance;
	
        public static Singleton getInstance() {
		Singleton localInstance = instance;
		if (localInstance == null) {
			synchronized (Singleton.class) {
				localInstance = instance;
				if (localInstance == null) {
					instance = localInstance = new Singleton();
				}
			}
		}
		return localInstance;
	}
} Не смотря на то, что этот вариант выглядит как идеальное решение, использовать его не рекомендуется т.к. товарищ Allen Holub заметил, что использование volatile модификатора может привести к проблемам производительности 
на мультипроцессорных системах. Но решать все же вам.


Это лучшая реализация для стат полей ибо обращаться из внутреннего стат класса к нестатическим полям нельзя.
public class Singleton {
		
	public static class SingletonHolder {
		public static final Singleton HOLDER_INSTANCE = new Singleton();
	}
		
	public static Singleton getInstance() {
		return SingletonHolder.HOLDER_INSTANCE;
	}
}
Лучше не ленивая инициализация.



95.Что можете сказать про MVC? Нарисуйте диаграмму и объясните, как MVC работает.
Нуу понятно.

96.Напишите функцию вычисления факториала.
public int fact(int num) {
     return (num == 0) ? 1 : num * fact(num - 1);
}


97. Дана функция вычисления чисел Фибоначчи, известно, что она работает. Найдите логическую ошибку. Оцените сложность получившегося алгоритма.
Числа Фибоначчи: линейная рекуррентная последовательность натуральных чисел, где первое и второе равно единице, а каждое последующее — сумме двух предыдущих:
 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377



Исключения (оглавление)

98. Дайте определение понятию “исключение”
Исключениями или исключительными ситуациями (состояниями) называются ошибки, возникшие в программе во время её работы.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.



99.  Какова иерархия исключений.
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.
Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы и предсказуемы. Например, произошло деление на ноль в целых числах.
Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, 
поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. 
Программа дополнительную память всё равно не сможет обеспечить для JVM.
В Java все исключения делятся на три типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и 
исключения времени выполнения (RuntimeExceptions, потомок класса Exception).
Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception
 (но не RuntimeException).



100. Можно/нужно ли обрабатывать ошибки jvm?
Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, 
поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. 
Программа дополнительную память всё равно не сможет обеспечить для JVM.


101. Какие существуют способы обработки исключений?
Обработка исключения может быть произведена с помощью операторов try…catch, либо передана внешней части программы. Например, метод может передавать возникшие 
в нём исключения выше по иерархии вызовов, сам его не обрабатывая.


102. О чем говорит ключевое слово throws?
public static void main(String[] args) throws Throwable {}
Говорит о том что в методе может возникнуть такое исключение и оно там не обрабатывается а передается выше.


103. В чем особенность блока finally? Всегда ли он исполняется?
Всегда, не выполняется только если я прибиваю JVM например используя метод System.exit(1); System.exit(42);Runtime.getRuntime().exit(42);Runtime.getRuntime().halt(42);



104. Может ли не быть ни одного блока catch при отлавливании исключений?
Да может быть catch и finally.
При выходе из метода вам надо произвести какое-либо действие. А return в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым return нецелесообразно.
Гораздо проще и эффективнее поместить основной код в try, а код, выполняемый при выходе – в finally.





105. Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?
1.Существуют потоки- Демоны- потоки предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы,но при этом не являются ее неотъемлеммой частью.
Таким образом когда все потоки не демоны завершаются,
 программа завершает свою работу. В потоках демонах блок finally не выполняеться, они прерываются внезапно.
2.не выполняется если я прибиваю JVM например используя метод System.exit(42);Runtime.getRuntime().exit(42);Runtime.getRuntime().halt(42);
3.Если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполнятся.



106. Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований)?
Да Конечно, если сразу ловить Exception то этим я поймаю все исключения.



107. Что вы знаете об обрабатываемых и не обрабатываемых (catched/uncatched) исключениях?
checked/unchecked. Если checked исключение не отлавливается, то это приводит к ошибке на этапе компиляции. Unchecked исключение - то, которое разработчик не должен допустить, 
т.к. имеет для этого возможность. 
Если исключение потомок RuntimeException или Error, то это unchecked исключение. Если исключение потомок Exception (и не потомок RuntimeException), то это checked исключение.
К unchecked исключениям относятся, например, NullPointerException, ArrayIndexOutOfBoundsException, ClassCastExcpetion и так далее. Это те ошибки, 
которые могут возникнут практически в любом методе. Несомненно, описывать каждый метод как тот, который бросает все эти исключения, было бы глупо.



108. В чем особенность RuntimeException?
Это unchecked Exception
Исключения, порожденные от RuntimeException, являются непроверяемыми и компилятор не требует обязательной их обработки. Как правило, это ошибки программы, которые при правильном кодировании возникать не должны 
(например, IndexOutOfBoundsException- выход за границы массива, java.lang.ArithmeticException- деление на ноль). 
Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков try-catch.
перехват исключений (catch) происходит в момент выполнения (runtime checking)


109. Как написать собственное (“пользовательское”) исключение? Какими мотивами вы будете руководствоваться при выборе типа исключения: checked/unchecked?
Ничего сложного можно наследоваться от Exception,RuntimeException,Error


110. Какой оператор позволяет принудительно выбросить исключение?
Throw
например throw new Error();



111. Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?
    Не знаю Throws может стоять


112. Может ли метод main выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
   Да может.Исключения проброшенные вверх методом main вам обработает виртуальная машина. 


113. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?
     Тот что в finally.
try {
  return "foo";
} finally { 
  return "bar";
}   //тут вернется bar

String value = "foo";
try {
  return value;
} finally {
  value = "bar";
}  //тут вернется foo

while(true) {   //Результат будет «bar». Это было удивлением даже для меня, однако все логично, если вы знаете, что оператор break всего лишь GOTO в байт-коде. 
                //Т.е. когда finally-блок подставляется как часть внутреннего оператора return, оператор GOTO вызывается раньше, чем инструкция RETURN, что приводит к выходу из цикла. (То же самое для оператора continue внутри finally-блока.)
  try {
    return "foo";
  } finally {
    break;
  }
}
return "bar";   //вернется bar




114. OutOfMemoryError
     Возникает:
     1.Не хватает место в куче, а именно, в области памяти в которую помещаются объекты, создаваемые программно в вашем приложении. Размер задается параметрами -Xms и -Xmx. 
       Если вы пытаетесь создать объект, а места в куче не осталось, то получаете эту ошибку. Обычно проблема кроется в утечке памяти, коих бывает великое множество, и интернет просто пестрит статьями на эту тему.
     2.Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize. 
       Что там лежит и как бороться с OutOfMemoryError возникающей там, я уже описал подробнейшим образом тут. 
     3. Много потоков. Впервые я столкнулся с данной ошибкой несколько лет назад, когда занимался нагрузочным тестированием и пытался выяснить максимальное количество пользователей, которые могут работать с нашим веб-приложением. 
        Я использовал специальную тулзу, которая позволяла логинить пользователей и эмулировать их стандартные действия. На определенном количестве клиентов, я начал получать OutOfMemoryError.


115. SQLException и поинтересоваться, оно chekced или unchecked и нормально ли это по мнению кандидата.
    Это checked и оно нужно.чтобы заставить девелопера насильно ловить в блоках кода это исключение, поскольку тут возможно много ошибок.Можно сделать RollBack транзакции.
    Нужно перобразовать его во что то более читаемое и сделать из него RuntimeException




116. Что такое Error? В каком случае используется Error. Приведите пример Error’а.
 Исключения, порожденные от Error, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно 
 (хотя формально обработчик допускается).
 Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти).



117. Какая конструкция используется в Java для обработки исключений?
try-catch


118. Возможно ли использование блока try-finally (без catch)?
При выходе из метода вам надо произвести какое-либо действие. А return в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым return нецелесообразно.
Гораздо проще и эффективнее поместить основной код в try, а код, выполняемый при выходе – в finally.


119. Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. 
Какое из двух исключений “выпадет” из блока try-finally? Что случится со вторым исключением?
Из блока try finally выпадет второе исключение, которое случилось в блоке finally, первое будет утеряно.



120. Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой оследовательности должны идти блоки catch? 
Сколько блоков catch будет выполнено?
Если срабатывает один из блоков catch, то остальные блоки в данной конструкции try-catch выполняться не будут.Блоки должны идти от наследника к родителю то есть:
Try{}
Catch(FileNotFoundException e){}
Catch(IOException e){}






Коллекции (оглавление)

121. Дайте определение понятию “коллекция”. 
Набор объектов. Связанный.
Поэтому все современные базовые библиотеки различных языков программирования имеют тот или иной вариант поддержки коллекций объектов. Коллекции обладают одним важным свойством — их размер не ограничен.
Массив - не коллекция, это конечно простейший тип коллекции но он не относится к Коллекциям.


122. Назовите преимущества использования коллекций.
   блин нууу не знаю


123. Какие данные могут хранить коллекции?
    Объекты. От класса Object.



124. Какова иерархия коллекций?
Collection-> Set,List,Queue(интерфейсы)
Set->HashSet,TreeSet,SortedSet(интерфейс, его реализует TreeSet)
List->Vector,ArrayList,LinkedList
Stack - реализация Vector

Map->WeakHashMap,HashMap,SortedMap(интерфейс),HashTable
SortedMap-> TreeMap

Stack -
данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления push()). 
После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque.


125. Что вы знаете о коллекциях типа List?
 Реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам
 коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).



126. Что вы знаете о коллекциях типа Set?
Представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество».


127. Что вы знаете о коллекциях типа Queue?
Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out). Помимо методов, определённых в интерфейсе Collection, 
определяет дополнительные методы для извлечения и добавления элементов в очередь.Большинство реализаций данного интерфейса находится в пакете java.util.concurrent
Обычно, очередь не позволяет добавлять null элементы из-за того, что null используется как служебный объект метода poll() и peek(). Однако в некоторых реализациях интерфейса Queue есть 
возможность добавление null элементов (например, LinkedList). Также не разрешается добавлять элементы, которые не можно сравнить с помощью класса Comparator.
Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» 
потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.



128. Что вы знаете о коллекциях типа Map, в чем их принципиальное отличие?
Данный интерфейс также находится в составе JDK c версии 1.2 и предоставляет разработчику базовые методы для работы с данными вида «ключ — значение».Также как и Collection, он был дополнен дженериками в версии Java 1.5 
и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые зачастую реализовались в логике приложения 

HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения.
 Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, 
получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n). Более подробную информацию о HashMap можно почитать здесь (актуально для Java < 8). 




129. Назовите основные реализации List, Set, Map.
set->HashSet,TreeSet 
List->ArrayList,Vector,LinkedList
Map->HashMap,HashTable,TreeMap



130. Какие реализации SortedSet вы знаете и в чем их особенность?
ConcurrentSkipListSet, TreeSet
TreeSet - Класс TreeSet создаёт коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном порядке по возрастанию либо сортируются исходя из компаратора,который можно задать в конструкторе.
TreeSet — аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает его поведение.

ConcurrentSkipListSet - создаёт коллекцию. Объекты сохраняются в отсортированном порядке по возрастанию либо сортируются исходя из компаратора,который можно задать в конструкторе. 
В основе лежит ConcurrentSkipListMap.
Skiplist — это рандомизированная альтернатива деревьям поиска, в основе которой лежит несколько связных списков. Была изобретена William Pugh в 1989 году. 
Операции поиска, вставки и удаления выполняются за логарифмически случайное время.
Скоростные линии соединяют некоторые станции
Обычные линии соединяют все станции
Есть обычные линии между общими станциями скоростных линий
Идея в следующем: мы можем добавить некоторое количество уровней с некоторым количеством узлов в них, при этом узлы в уровнях должны быть равномерно распределены. 
Рассмотрим пример, когда на каждом из вышележащих уровней располагается половина элементов из нижележащего уровня.




131.В чем отличия/сходства List и Set?
List -отсортированный, может хранить одинаковые элементы,любое кол-во null эементов.Есть индекс, можно по нему обращаться.
Set - множество уникальных объектов, неотсортировано.





132.Что разного/общего у классов ArrayList и LinkedList, когда лучше использовать ArrayList а когда LinkedList?
ещё одина реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список 
(каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1). 
Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь. Для этого в ней реализованы соответсвующие методы.

ArrayList — как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве.
 Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу.

LinkedList надо использовать если нужно часто вставлять/удалять элементы в средину коллекции. ArrayList - когда просто добавлять/удалять в конец или начало.




133. В каких случаях разумно использовать массив, а не ArrayList?
Когда известно кол-во элементов, нужна производительность,или примитивные типы - массив. Иначе ArrayList.


134. Чем отличается ArrayList от Vector?
 Vector — реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но как и Hashtable,
 эту коллекцию не рекомендуется использовать, если не требуется достижения потокобезопасности. Потому как в Vector, в отличии от других реализаций List, все операции с данными являются синхронизированными. 
 В качестве альтернативы часто применяется аналог — ArrayList.

 как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. 
 Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1).
 Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции. Подробный анализ и описание можно почитать в этом хабратопике.
 Отличие - Vector -потокобезопасный, ArrayList нет. И ArrayList основан на массиве.Быстрое обращение по индексу.



135. Что вы знаете о реализации классов HashSet и TreeSet?
HashSet — реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, 
а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.

TreeSet аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator,
 либо сохраняет элементы с использованием "natural ordering". Для хранения элементов применяет дерево.






136. Чем отличаются HashMap и TreeMap? Как они устроены и работают? Что со временем доступа к объектам, какие зависимости?
HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. 
Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции.
 Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции.

TreeMap - реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering",
 но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, которые указывается в качестве параметра при создании объекта TreeMap.




137. Что такое Hashtable, чем она отличается от HashMap? На сегодняшний день она deprecated, как все-таки использовать нужную функциональность?
Hashtable — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, 
но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). 
Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.




138. Что будет, если в Map положить два значения с одинаковым ключем?
Значение по ключу затрется новым значением. Метод put() вернет старое значение.
 


139. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
Все элементы хранятся в порядке добавления или вообще не отсортированы.
1.Можно реализовать у Объектов коллекции интерфейс Comparable(), реализовать там метод compareTo().И вызвать сортировку,например Collections.sort(list).
  Natural Ordering - это у некоторых классов реализован уже интерфейс Comparable в соот. с которым они сортируются. Например String, Integer.

2. Использовать компаратор.
public class PeopleBirthdayComparator implements Comparator<People> {
 
    @Override
    public int compare(People people1, People people2) {
        return people1.getBirthday().compareTo(people2.getBirthday());
    }
 
}
или
public class PeopleAgeComparator implements Comparator<People> {
    @Override
    public int compare(People people1, People people2) {
        return people1.getAge() - people2.getAge();
    }
}

Его можно юзать так peoples = new TreeSet<People>(new PeopleAgeComparator());
или Collections.sort(list,new PeopleAgeComparator())



140. Дайте определение понятию “итератор”.
Итератор — это объект, который позволяет программисту пробежать по элементам коллекции.
Без него не получится пробежаться по Set.
boolean hasNext() — метод возвращает true, если в коллекции ещё остались элементы и false, если достигнут конец коллекции.
E next() — метод возвращает текущий элемент. Т.к. итератор является параметризованным классом, то этот метод нам будет возвращает не Object, 
а сразу тот тип, которы нам нужен.





141. Какую функциональность представляет класс Collections?
Состоит только из статических методов, которые принимают коллекции как параметр и производят операции над ней или возвращают коллекцию.
Он содержит:
?	Полиморфные алгоритмы для работы с коллекциями,например:
•binarySearch •copy •	min и max •replace •reverse •rotate •shuffle •sort •swap
?	«Обертки» – возвращают новые коллекции на основе имеющихся
•	Синхронизированные коллекции
•	Не модифицируемые коллекции
Классы Collections и Arrays это специальные служебные классы, для работы с классами-коллекциями. 
Они позволяют преобразовывать коллекции, делать их защищенными от записи или потокобезопасными, сортировать их разными способами и т.д.



142. В чем разница между HashMap и HashTable?
Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения.
Третье ключевое отличие между ними — итератор у HashMap, в отличие от перечислителя HashTable, работает по принципу fail-fast 
(выдает исключение при любой несогласованности данных)



143. Какой предок у класса HashTable?
Dictionary<K,V> абстрактный предок всех классов, которые связывают ключ со значением. 
Это устаревший класс, весь подобный функционал реализуется через Map интерфейс.





144. Как получить не модифицируемую коллекцию?
Немодифицируемые коллекции - это как правило обертки других коллекций, и там нет операций по добавлению,изменению, удалению.
Immutable - это неизменяемые класс со своими данными. У них нет методов для изменения данных.
Методы класса Collections:
public static <T> List<T> unmodifiableList(List<? extends T> list)
public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K,? extends V> m)
public static <T> Set<T> unmodifiableSet(Set<? extends T> s)
и прочие возвращают неизменяемые коллекции, при попытке изменения данных получим UnsupportedOperationException


145. Какие коллекции синхронизированы?
HashTable,Vector,Stack(кроме метода push)




146. Как получить синхронизированную коллекцию из не синхронизированной?

Collections.synchronizedCollection(Collection<T> c);
Collections.synchronizedList(List<T> list)
Collections.synchronizedMap(Map<K,V> m)
Collections.synchronizedSet(Set<T> s)
Проход по списку такой:
 List list = Collections.synchronizedList(new ArrayList());
      ...
  synchronized (list) {
      Iterator i = list.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }

  Map m = Collections.synchronizedMap(new HashMap());
      ...
  Set s = m.keySet();  // Needn't be in synchronized block
      ...
  synchronized (m) {  // Synchronizing on m, not s!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 




147. Как получить коллекцию только для чтения?
Используйте следующие методы:
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
Все они принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.



148. Почему Map не наследуется от Collection?
Хороший ответ на этот вопрос — «потому что они несовместимы». В интерфейсе Collection описан метод add(Object o). Словари не могут содержать этот метод,
 потому что работают с парами ключ/значение. Также, словари имеют представления keySet, valueSet, которых нет в коллекциях.
В связи с этими различиями, интерфейс Map не может наследовать интерфейс Collection, и представляет собой отдельную ветвь иерархии.





149. В чем разница между Iterator и Enumeration?
По сути это одно и тоже, но Iterator более предпочтителен, так Enumeration используется только в устаревших классах.
Итераторы отличаются от перечислителей по трем признакам:
-Существуют итераторы, которые позволяют удалять элементы из своей коллекции во время перебора, с использованием метода remove(). 
Класс Enumeration данного функционала не поддерживает. С помощью перечислителя нельзя добавлять/удалять элементы

-Перечислители присутствуют в устаревших классах, таких как Vector/Stack, тогда как итераторы есть во всех современных классах-коллекциях

-Еще небольшое отличие в том, что у итераторов и перечислителей различается наименование методов, то есть Enumeration.hasMoreElements() соответствует 
Iterator.hasNext() и Enumeration.nextElement() соответствует Iterator.next() и т.д.



150. Как реализован цикл foreach?
Цикл в стиле foreach предназначен для строго последовательного выполнения повторяющихся действий по отношению к коллекциям объектов, например, таких как массивы. 
В Java возможность применения цикла foreach реализована за счет усовершенствования цикла for.  Общая форма версии foreach цикла for имеет следующий вид:
for (тип итерационная переменная : коллекция) блок-операторов



151. Почему нет метода iterator.add() чтобы добавить элементы в коллекцию?
Единственная задача итератора это перебор коллекции. Каждая коллекция имеет метод add() которым вы можете воспользоваться. 
Нет смысла добавлять этот метод в итератор, потому что коллекции могут быть упорядоченными и неупорядоченными, и метод add() при этом должен быть устроен по разному.



152. Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?
Потому, что нет метода передвижения курсора, next() - сразу получает элемент и двигает курсор.






153. В чем разница между Iterator и ListIterator?
Есть три различия:
Iterator может использоваться для перебора элементов Set, List и Map. В отличие от него, ListIterator может быть использован только для перебора элементов коллекции List
Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). Тогда как ListIterator позволяет перебирать список в обоих направлениях,
 при помощи методов next() и previous()
При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove(). Iterator не поддерживает данного функционала




154. Какие есть способы перебора всех элементов List?
Есть 4 способа:
1. Цикл с итератором
2. Цикл foreach
3. Расширенный цикл for через индекс
4. Цикл while







155. В чем разница между fail-safe и fail-fast свойствами?
Итератор fail-fast вызывает исключение сразу как обнаружит что структура коллекции была изменена после начала перебора. 
Под изменением структуры мы понимаем добавление/удаление/изменение элемента коллекции, в то время как другой поток перебирает эту коллекцию.
Все Итераторы из фреймворка Коллекции - fail-fast.

В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.
Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe.




156. В каких случаях может быть выброшено ConcurrentModificationException?
Когда делаются изменения,если они запрещены.Например, изменение коллекции во время ее перебора в другом потоке.

Как избежать:
Первым делом, можно подобрать другой итератор, работающий по принципу fail-safe. К примеру, если вы используете List, то можете взять ListIterator.
 Если же вам нужна устаревшая коллекция — то используйте перечислители.
В том случае, когда вышеизложенное вам не подходит, у вас есть три варианта:
При использовании JDK 1.5 или выше, вам подойдут классы ConcurrentHashMap и CopyOnWriteArrayList. Это самый лучший вариант
Вы можете преобразовать список в массив и перебирать массив
Вы можете блокировать изменения списка на время перебора с помощью блока synchronized
Обратите внимание, что последние два варианта негативно скажутся на производительности.





157. Что такое стек и очередь, расскажите в чем их отличия?
Коллекции, созданные для того чтобы хранить элементы для дальнейшей обработки. Кроме базовых операций интерфейса Collection, очереди поддерживают дополнительные операции
 добавления, удаления и проверки состояния элемента.
Обычно, но не обязательно очереди работают по принципу FIFO — первым пришел, первым ушел.
Стэк — почти как очередь, но работает по принципу LIFO — последним пришел, первым ушел.
Независимо от порядка добавления/удаления, голова очереди это элемент, который будет удален при вызове методов remove() или poll(). Также обратите внимание на то,
 что Stack и Vector оба потокобезопасны.

Использование: Используйте очередь если вы хотите обрабатывать поток элементов в том же порядке в котором они поступают. Хорошо для списка заданий и обработки запросов.
Используйте стэк если вы хотите класть и удалять элементы только с вершины стэка, что полезно в рекурсивных алгоритмах.

(А теперь отвлечемся и объясним все чуть иначе.
Итак, представьте обойму автомата. Вы вставляете туда патроны по одному, только с одного конца. И с этого же конца, 
по одному их будет забирать затворный механизм при стрельбе. Это — стэк, положить элемент можно только на его вершину, снять оттуда же и больше ниоткуда. 
Последний положенный элемент будет снят первым.
Очередь — как трубка, в которую вы можете закатывать шарики, и с другого конца их забирать. Очередь позволяет класть элементы только в свой хвост, 
а забирать только с головы. Тот элемент который был первым положен, первым же будет и забран. 
Общее у очереди и стэка только то, что у них обоих есть фиксированное место куда можно положить элемент, и фиксированное место откуда его можно забрать — 
все остальные элементы недоступны.(Прим. пер.))

Stack — данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). 
Является частично синхронизированной коллекцией (кроме метода добавления push()). 
После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque.
Deque - A linear collection that supports element insertion and removal at both ends.






158. В чем разница между интерфейсами Comparable и Comparator?
В Java, все коллекции поддерживающие автоматическую сортировку, используют методы сравнения для того чтобы правильно рассортировать элементы. В качестве примера 
таких классов мы можем указать TreeSet, TreeMap и т.д.
Для того чтобы рассортировать элементы, класс должен реализовать интерфейсы Comparator или Comparable. Именно поэтому классы-обертки как Integer, 
Double и String реализуют интерфейс Comparable. 
Интерфейс Comparable помогает сохранять естественную сортировку, тогда как Comparator позволяет сортировать элементы по разным особым шаблонам. 
Экземпляр компаратора обычно передается конструктору коллекции, если коллекция это поддерживает.

(Снова объясняю по другому.
Интерфейс Comparator описывает метод int compare(T o1, T o2), то есть объект реализующий этот интерфейс может быть использован для сравнения
 двух других объектов одного класса. Если данный метод вернет 0 — объекты равны, +1 и -1 говорят о том что первый объект «больше» второго или наоборот.
 Какой смысл вы вложите в понятие «больше» и «меньше» применительно к вашим объектам — исключительно ваше дело. То есть — вы описываете класс,
 реализующий интерфейс Сomparator, и в данном методе определяете как вы хотите сравнивать ваши объекты. Потом передаете объект этого класса конструктору коллекции, 
в которой хранятся объекты сравниваемые данным методом, и коллекция сможет их сортировать по возрастанию/убыванию. Повторяю — у вас есть коллекция 
в которой хранятся объекты класса T, и есть еще один объект, другого класса, реализующего интерфейс Comparator, вся суть которого в том что он умеет сравнивать эти объекты 
класса T, больше он ни для чего не нужен.
Интерфейс Comparable описывает метод int compareTo(T o), то есть вызывается он не для сравнения двух других объектов, а для сравнения себя самого с кем-то еще. 
То есть, вам не нужен отдельный объект-сравниватель, вы закладываете механизм сравнения в сам элемент хранящийся в коллекции. 
Что и в какой ситуации удобнее — решать вам.(Прим. пер.))



159. Почему коллекции не наследуют интерфейсы Cloneable и Serializable?
Ну, простейший ответ — «потому что не надо». Функционал предоставляемый интерфейсами Cloneable и Serializable просто не нужен для коллекций.

Еще одна причина — далеко не всегда нужен подкласс Cloneable потому что каждая операция клонирования потребляет очень много памяти, 
и неопытные программисты могут расходовать ее сами не понимая последствий.

И последняя причина — клонирование и сериализация являются очень узкоспецифичными операциями, и реализовывать их нужно только когда это необходимо.
 Многие классы коллекции реализуют данные интерфейсы, но совершенно незачем закладывать их для всех коллекций вообще. 
Если вам нужно клонирование и сериализация — просто воспользуйтесь теми классами где она есть, если нет — остальными классами.



160. Какие алгоритмы сортировки Вам известны? Какие вообще знаете алгоритмы?
1.Пузырьковый - учебный, долгий, неэффективный - просто сравниваются пары пока не нужны будут сравнения.
2.Быстрая сортировка
выбрать элемент, называемый опорным.
сравнить все остальные элементы с опорным, на основании сравнения разбить множество на три — «меньшие опорного», «равные» и «большие», расположить их в порядке меньшие-равные-большие.
повторить рекурсивно для «меньших» и «больших».
3.Сортировка расчёской

161. Алгоритмы. Методы сортировки: quick sort, merge sort, radix sort; hash map, linked list, binary search tree; semaphore, thread pool, blocking queue
да ну их втопку

162. Как посчитать среднее массива?
Не понял вопроса, никогда такой вопрос не задавали. Чего проще то.




163. Что быстрее, HashMap или TreeMap?
HashMap это очень широко используемый класс, и вы это знаете. Так что, я ограничусь тем, что скажу что в нем хранятся пары ключ/значение и он позволяет проводить над ними 
многие операции.

TreeMap это особая разновидность HashMap. Разница в том, что ключи в TreeMap хранятся упорядоченно. По умолчанию применяется «естественная сортировка». 
Переопределить сортировку можно предоставив экземпляр класса Comparator, метод compare которого и будет использован для сортировки ключей.

Обратите внимание, что все ключи добавленные в словарь должны реализовывать интерфейс Comparable (это необходимо для сортировки). Более того, все ключи должны быть
 взаимно совместимыми:k1.compareTo(k2) не должен вызывать ClassCastException для любых k1 и k2 хранящихся в словаре. 
Если пользователь попытается положить в словарь ключ который нарушает это условие (к примеру, строковый ключ в словарь где все ключи типа Integer), 
метод put(Object key, Object value) должен вызвать ClassCastException.
HashMap быстрее.


163.1. Какие классы коллекций позволяют доступ к любому элементу?
Классы ArrayList, HashMap, TreeMap, Hashtable позволяют доступ к любому элементу.


163.2. Что такое BlockingQueue?
Это очередь, которая позволяет обрабатывать ситуации, когда из пустой очереди пытаются получить элемент, или когда пытаются добавить элемент в очередь, 
а место в ней закончилось.
Методы блокирующей очереди могут быть четырех типов: Первые вызывают исключение, вторые возвращают специальные значения (null или false, в зависимости от операции),
 третьи блокируют текущий поток до тех пор пока операция не может быть выполнена, и четвертые блокируют поток только на определенный промежуток времени.


163.3.Как преобразовать массив строк в ArrayList?
List wordList = Arrays.asList(words);
Также хотелось бы отметить, что этот метод способен обрабатывать не только строки, он создаст список элементов любого типа, которого был массив.
Integer[] nums = {1, 2, 3, 4};
List numList = Arrays.asList(nums);


163.4. Что такое IdentityHashMap и WeakHashMap?
IdentityHashMap похож на HashMap за одним исключением — для сравнения объектов используется сравнение указателей на объекты, если указатели не равны 
(указывают на объекты лежащие по разным адресам), значит объекты считаются различными. IdentityHashMap является довольно редко используемым. Хотя он реализует интерфейс Map, 
он нарушает один из основных принципов устройства Map, который требует использования метода equals() для сравнения объектов. IdentityHashMap используется только в тех случаях,
 когда требуется сравнение объектов по их адресам.

WeakHashMap это реализация интерфейса Map, которая содержит слабые ссылки на элементы. То есть, если за пределами WeakHashMap не осталось ни одной ссылки на его элемент, 
этот элемент удаляется сборщиком мусора. Класс предназначен для использования с объектами, у которых метод equals() проверяет идентичность объектов с помощью оператора ==. 
После того как элемент будет удален сборщиком мусора, он уже не может быть восстановлен, и к большому удивлению программиста найти его в словаре больше не получится.


163.5. Объясните что такое ConcurrentHashMap? Как оно работает?
Взято с официальной документации:
Реализация словаря полностью поддерживающая многопоточное добавление/удаление/поиск элементов. Данный класс следует тем же спецификациям что и Hashtable, 
и содержит методы соответствующие методам Hashtable. Однако, хотя все операции являются потокобезопасными, операция по выборке элементов не блокирует таблицу, 
и вообще нет возможности запретить весь доступ к таблице. Этот класс совместим с Hashtable во всем кроме вопросов многопоточной синхронизации.



163.6. Как создать хороший ключ для словаря?(ХэшМапа)
Следующий хороший вопрос, который обычно задают следом за вопросом о функционировании HashMap. Итак, главное ограничение — ключ должен быть таким, чтобы потом по нему 
можно было получить из словаря значение. Иначе в его использовании просто нет смысла. Если вы понимаете как функционирует hashmap, вы знаете что его работа сильно зависит от 
методов hashCode() и equals() объектов-ключей.

Как следует из вышеизложенного, хороший ключ должен давать один и тот же hashCode снова и снова, независимо от того сколько раз он запрашивается. 
А также, одинаковые ключи, при вызове метода equals() должны возвращать true, а разные — false.

Из чего следует, что лучшими кандидатами на роль ключа являются неизменяемые классы.



Строки (оглавление)

164. Какие “строковые” классы вы знаете?
String, StringBuffer, StringBuilder


165. Какие основные свойства “строковых” классов (их особенности)?
String - всегда создает новый объект.Неизменяемый
StringBuffer - изменяемый строковый класс, потокобезопасный, старый.
StringBuilder - изменяемый строковый класс, не потокобезопасный, новый, более производительный.
Поэтому для работы в многопоточной среде и используется либо String, либо StringBuffer, а для работы с одним потоком используется StringBuilder.
Также стоит отметить, что производительность StringBuilder больше чем у StringBuffer, так как у первого отсутствуют расходы связанные с обеспечением потокобезопасности.


166. Можно ли наследовать строковый тип, почему?
Одна из главнейших причин, почему String класс является final, это неизменяемость (immutable) объектов String. То что он final, означает, 
что никто не сможет наследовать этот класс и соответственно переопределить (override) функциональность класса (переопределить методы). 



167. Дайте определение понятию конкатенация строк.
Соединение, методы append, a+b, String.concat(String)



168. Как преобразовать строку в число?
1.new Integer("20349");
2.Integer.valueOf(str1);
3.Integer.parseInt(str2);
Аналогично другие числовые типы.




169. Как сравнить значение двух строк?
String.equals()




170. Как перевернуть строку?
1.    public static String reverseByArray(String s) {
        char[] a = s.toCharArray();
        char[] b = new char[a.length];
        for (int i = 0; i < a.length; i++) {
            b[(a.length - 1) - i] = a[i];
        }
        return new String(b);
    }
 
2.    public static String reverseByStringBuilder(String s) {
        return new StringBuilder(s).reverse().toString();
    }

3. Использовать Stack




171. Как работает сравнение двух строк?
== ссылки сравнивает
equals() -значения




172. Как обрезать пробелы в конце строки?
trim() -удаляет крайние пробелы строки
StringUtils.stripEnd(String str, String stripChars); StringUtils.stripEnd("  abc  "," "); 



173. Как заменить символ в строке?
replace(char oldChar, char newChar);
replaceFirst(String regex, String replacement);


174. Как получить часть строки?
String  substring(int beginIndex)-Returns a new string that is a substring of this string.
String	substring(int beginIndex, int endIndex) - Returns a new string that is a substring of this string.



175. Дайте определение понятию “пул строк”.
String Pool - это пул строк, хранящихся в Java Heap Memory (область памяти известная по -русски как куча). Когда мы создаем строку без использования оператора new, 
то JVM ищет строку с таким значением в String Pool, если находит, то возвращает ссылку на уже существующий объект, если не находит, то помещает новый объект в пул.

Так как строки в Java программах используются очень часто, то использование пула строк способствует уменьшению расхода памяти. Однако стоит заметить, 
что создание строки с использованием оператора new занимает меньше времени, т.к. JVM не нужно сравнивать строку с уже существующими в пуле значениями.




176. Какой метод позволяет выделить подстроку в строке?
indexOf(String str)
Returns the index within this string of the first occurrence of the specified substring.


177. Как разбить строку на подстроки по заданному разделителю?
split(String regex)
Splits this string around matches of the given regular expression.


178. Какой метод вызывается для преобразования переменной в строку?
1. toString()
2. String.valueOf()



179. Как узнать значение конкретного символа строки, знаю его порядковый номер в строке?
charAt(int index)
Returns the char value at the specified index.



180. Как найти необходимый символ в строке?
indexOf(String str)
Returns the index within this string of the first occurrence of the specified substring.



181. Можно ли синхронизировать доступ к строке?
Можно, но строка неизменяемая, поэтому смысла нет. Если пользоваться изменяемым объектом, то лучше пользовать StringBuffer.




182. Что делает метод intern()?
При вызове метода intern() на строке, если String Pool содержит строку эквивалентную этой строке, то метод вернет строку из пула строк.


183. Чем отличаются и что общего у классов String, StringBuffer и StringBuilder?
Всегда ипользуйте StringBuilder, кроме случаев, когда вам необходимо использовать конкретно StringBuffer, 
так как в StringBuilder нету синхронизированных методов в отличие от StringBuffer и следовательно производительность будет выше, хоть и не значительно.



184. Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?
перевести StringBuffer.toString




184.1 Можем ли мы использовать строку в конструкции switch.
Этот хитрый вопрос, используется для проверки ваших знаний о текущем развитии языка. Java 7 расширяет возможности оператора switch для использования строк,
 ранние версии Java не поддерживают этого.
Если вы реализуете условный поток для строк, вы можете использовать условия if-else и вы можете использовать оператор switch, если используете Java 7 или поздние версии.
Небольшой пример использования строки в операторе switch и другой метод, который показывает такую же логику, используя условия if-else.








Потоки ввода/вывода (оглавление)

185. Какие существуют виды потоков ввода/вывода?
Ввод – вывод в Java осуществляется с помощью так называмых потоков в Java (stream), которая либо порождает, либо принимает информацию. 
Осуществление ввода – вывода с помощью потоков имеет свои плюсы, потому что поток скрывает все детали низкоуровневых процессов, 
происходящих с данными непосредственно в устройствах ввода - вывода. Все потоки ведут себя на одинаково, даже несмотря на то, что реальные физические устройства,
 к которым они подключена, отличаются друг от друга. Таким образом, одни и те же классы и методы ввода – вывода применимы к устройствам разного типа. 
Это означает, что абстракция входного потока может охватить разные типы ввода: из дискового файла, клавиатуры или сетевого сокета. Аналогично выходной поток 
может ссылаться на консоль, дисковый файл или сетевое подключение. 
Потоки – это ясный способ обращения с вводом – выводом без необходимости для вашего кода разбираться с разницей, например между клавиатурой и сетью. 
Java реализует потоки внутри иерархии классов, определенных в пакете java.io. Java определяет два типа потоков: байтовые и символьные. 
Байтовые потоки предоставляют удобные средства для управления вводом и выводом байтов.
 Байтовые потоки используются, например, при чтении и записи бинарных данных. Обычный консольный ввод- вывод идет через байтовые потоки. 
Символьные потоки предлагают удобные возможности управления вводом и выводом символом. Они используют кодировку Unicode и, таким образом, могут быть интернационализированы. 
Кроме того, в некоторых случаях символьные потоки более эффективны, чем байтовые.


186. Назовите основные предки потоков ввода/вывода.
Основные абстрактные классы, от которых наследуют все классы байтового ввода – вывода, - InputStream и OutputStream.
 Каждый из этих абстрактных классов имеет несколько реальных подклассов, которые управляют различиями между различными устройствами, такими как дисковые файлы,
 сетевые подключения и даже буферы памяти. Абстрактные классы InputStream и OutputStream переопределяют несколько ключевых методов, которые реализует другие потоковые классы. 
Два наиболее важных – это read() и write(), которые, соответственно, читают и пишут байты данных. Оба метода обновлены как абстрактные внутри InputStream OutputStream. 
В классы – наследниках они переопределяются. Классы байтовых потоков перечислены ниже.
Классы байтовых потоков 
BufferedInputStream - Буферизированный входной поток 
BufferedOutpudStream - Буферизированный выходной поток. 
ByteArrayInputStream Входной поток, читающий из массива байт. 
ByteAOutputInputStream - Выходной поток, записывающий из массива байт 
DataInputStream - Входной поток, записывающий методы для чтения стандартных типов данных Java 
DataOutputStream - Выходной поток, включающий методы для записи стандартных типов Java. 
FileInputStream - Выходной поток, читающий из файла 
FileOutputStream - Входной поток, записывающий в файл. 
FilterInputStream - Реализация InputStream 
FilterOutputStream - Реализация OutputStream 
InputStream - Абстрактный класс, описывающий поток ввода. 
OutputStream - Абстрактный класс, описывающий поток вывода. 
ObjectInputStream - Входной поток для объектов. 
ObjectOutputStream - Выходной поток для объектов. 
PipedInputStream - Входной канал (например, межпрограммный). 
PipedOutpudStream - Выходной канал. 
PrintStream - Выходной поток, включающий print() и println(). 
PushbackInputStream - Входной поток, поддерживающий однобайтовый возврат. 
RandomAccessFile - Поддерживающий файловый ввод – вывод с произвольным доступом. 
SequenceInputeStream - Входной поток, представляющий собой комбинацию двух и более входных потоков, которые читаются совместно – один после другого. 


Основными абстрактными классами симовольного потока являются классы Reader и Writer. Эти абстрактные классы управляют потоками символов Unicode. 
В Java предусмотрено несколько конкретных подклассов для каждого из них. Абстрактные классы Reader и Writer определяют несколько ключевых методов, которые реализуют другие потоковые классы. 
Два наиболее важных – это read () и write(), которые, соответственно читают и пишут символьные данные. Эти методы переопределяются в потоковых классах – наследниках. Классы символьных потоков перечислены ниже. 

Классы символьных потоков BufferedReader - Буферизованный входной символьный поток. BufferedWriter - Буферизованный выходной символьный поток. CharArrayReader - Входной поток, котрый читает из символьного массива. 
CharArrayWriter - Выходной поток, котрый читает из символьного массива. FilterWriter - Фильтр Писатель. FilterReader - Фильтр читатель. FileWriter - Выходной поток, 
пишущий в файл FileReader - Входной поток, пишущий в файл InputStreamRader - Входной поток, транслирующий байты в символы. LineNumberReader - Входной поток, подсчитывающий строки. 
OutputStreamWriter - Выходной поток, транслирующий байты в символы. PipedReader - Входной канал. PipedWriter - Выходной канал PrintWriter - Выходной поток, включающий print() и println().
 PushbackReader - Входной поток, позволяющий возвращать символы обратно в поток. Reader - Абстрактный класс, описывающий символьный ввод. StringReader - Входной поток, читающий из строки. 
StringWriter - Входной поток, пишущий в строку. Writer - Абстрактный класс, описывающий символьный вывод



187. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?
InputStream, OutputStream - 1-й читает байты, второй записывает байты. Reader, Writer -1-й читает символы, второй их записывает.


188. Что вы знаете о RandomAccessFile?
Работа с классом RandomAccessFile напоминает использование совмещенных в одном классе потоков DataInputStream и DataOutputStream (они реализуют те же интерфейсы DataInput и DataOutput). 
Кроме того, метод seek() позволяет переместиться к определенной позиции и изменить хранящееся там значение.
При использовании RandomAccessFile необходимо знать структуру файла. Класс RandomAccessFile содержит методы для чтения и записи примитивов и строк UTF-8.
RandomAccessFile может открываться в режиме чтения ("r") или чтения/записи ("rw"). Также есть режим "rws", когда файл открывается для операций чтения-записи и каждое изменение данных файла
 немедленно записывается на физическое устройство.


189. Какие есть режимы доступа к файлу?
1. r - чтение
2. rw - чтение-запись
3. rws - чтение-запись сразу же, не дожидаясь flush().


190. В каких пакетах лежат классы-потоки?
java.io



191. Что вы знаете о классах-надстройках?
Класс надстройка - Абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства.
В java.io их еще называют фильтрами. При этом надстройка-фильтр включает в себя интерфейс объекта, на который надстраивается, поэтому может быть, в свою очередь, дополнительно надстроена.
В java.io интерфейс для таких надстроек ввода/вывода предоставля­ют классы FilterlnputStream (для входных потоков) и FilterOutputStream (для выходных потоков). 
Эти классы унаследованы от основных базовых классов ввода/вывода - InputStream и OutputStream, соответственно. 
Конструктор FilterlnputStream принимает в качестве параметра объект InputStream и имеет модификатор доступа protected.
Классы Filterl/OStream являются базовыми для надстроек и опреде­ляют общий интерфейс для надстраиваемых объектов. 
Потоки-надстройки не являются источниками данных. Они лишь модифицируют (расширяют) работу надстраиваемого потока.
Внутри надстройка содержится поток, который передается туда в конструкторе.

FilterReader и FilterWriter -для символьного ввода вывода.






192. Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?
Для чтения байтовых данных (не строк) применяется класс DataInputStream. В этом случае необходимо использовать классы из группы InputStream.
Для преобразования строки в массив байтов, пригодный для помещения в поток ByteArrayInputStream, в классе String предусмотрен метод getBytes(). 
Полученный ByteArrayInputStream представляет собой поток InputStream, подходящий для передачи DataInputStream.
При побайтовом чтении символов из форматированного потока DataInputStream методом readByte() любое полученное значение будет считаться действительным, 
поэтому возвращаемое значение неприменимо для идентификации конца потока. Вместо этого можно использовать метод available(), который сообщает, сколько еще осталось символов.
Класс DataInputStream позволяет читать элементарные данные из потока через интерфейс DataInput, который определяет методы, преобразующие элементарные значения в форму последовательности байтов.
 Такие потоки облегчают сохранение в файле двоичных данных.
Конструктор:
DataInputStream(InputStream stream)
Методы:
readDouble()
readBoolean()
readInt()




193. Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?
BufferedInputStream
Буферизация ввода-вывода является удобным способом оптимизации производительности, позволяя заключить в оболочку любой поток класса InputStream.
У класса есть конструктор, где размер буфера устанавливается по умолчанию. Также можно использовать конструктор, где размер буфера устанавливается вручную. 
Рекомендуется использовать размеры буфера, кратные размеру страницы памяти, дисковому блоку и т.п. и может зависеть от принимающей операционной системы, объёма доступной памяти и конфигурации машины.



194. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?
При помощи класса InputStreamReader вы можете преобразовывать байтовые потоки в символьные потоки. Вы используете класс OutputStreamWriter для перевода символьных потоков в байтовые потоки. 
Когда вы создаете объекты InputStreamReader и OutputStreamWriter, вы задаете байтовую кодировку, которую вы хотите преобразовывать. Например, чтобы перевести текстовый файл в кодировке UTF-8 в Unicode,
 вы создаете InputStreamReader слебующим образом:

FileInputStream fis = new FileInputStream("test.txt");
InputStreamReader isr = new InputStreamReader(fis, "UTF8");
Если вы опустите идентификатор кодировки, InputStreamReader и OutputStreamWriter будут обращаться к кодировке по умолчанию. Вы можете определить кодировку, 
используемую InputStreamReader или OutputStreamWriter, вызвав метод getEncoding, таким образом:

InputStreamReader defaultReader = new InputStreamReader(fis);
String defaultEncoding = defaultReader.getEncoding();
Следующий пример показывает вам, как выполнить преобразование набора символов при помощи классов InputStreamReader и OutputStreamWriter.
 Полный исходный код для этого примера находится в StreamConverter.java. Эта программа отображает японские символы. Прежде чем пытаться их вывести, убедитесь, 
что в вашей системе установлен соответствующий шрифт. Если вы используете программное обеспечение JDK, совместимое с версией 1.1, сделайте копию файла font.properties и замените его на файл font.properties.ja.
Программа StreamConverter преобразует последовательность символов Unicode из объекта String в поток байтов FileOutputStream, кодированный в UTF-8. Метод, который выполняет преобразование, называется writeOutput:
static void writeOutput(String str) {

    try {
	FileOutputStream fos = new FileOutputStream("test.txt");
	Writer out = new OutputStreamWriter(fos, "UTF8");
	out.write(str);
	out.close();
    } catch (IOException e) {
	e.printStackTrace();
    }
}



195. Какой класс предназначен для работы с элементами файловой системы (ЭФС)?
Существует множество классов и методов для чтения и записи файлов. Наиболее распространённые из них - классы FileInputStream и FileOutputStream, которые создают байтовые потоки, связанные с файлами.
 Чтобы открыть файл, нужно создать объект одного из этих файлов, указав имя файла в качестве аргумента конструктора.

FileInputStream(String filename) throws FileNotFoundException
FileOutputStream(String filename) throws FileNotFoundException
В filename нужно указать имя файла, который вы хотите открыть. Если при создании входного потока файл не существует, передаётся исключение FileNotFoundException. Аналогично для выходных потоков, 
если файл не может быть открыт или создан, также передаётся исключение. Сам класс исключения происходит от класса IOException. Когда выходной файл открыт, любой ранее существовавший файл с тем же именем уничтожается.
После завершения работы с файлом, его необходимо закрыть с помощью метода close() для освобождения системных ресурсов. Незакрытый файл приводит к утечке памяти.
В JDK 7 метод close() определяется интерфейсом AutoCloseable и можно явно не закрывать файл, а использовать новый оператор try-с-ресурсами, что для Android пока не слишком актуально.
Чтобы читать файл, нужно вызвать метод read(). Когда вызывается этот метод, он читает единственный байт из файла и возвращает его как целое число. Когда будет достигнут конец файла, то метод вернёт значение -1. 
Примеры использования методов есть в различных статьях на сайте.
Иногда используют вариант, когда метод close() помещается в блок finally. При таком подходе все методы, которые получают доступ к файлу, содержатся в пределах блока try, а блок finally используется для закрытия файла. 
Таким образом, независимо от того, как закончится блок try, файл будет закрыт.
Так как исключение FileNotFoundException является подклассом IOException, то не обязательно обрабатывать два исключения отдельно, а оставить только IOException, 
если вам не нужно отдельно обрабатывать разные причины неудачного открытия файла. Например, если пользователь вводит вручную имя файла, то более конкретное исключение будет к месту.
Для записи в файл используется метод write().
void write(int value) throws IOException
Метод пишет в файл байт, переданный параметром value. Хотя параметр объявлена как целочисленный, в файл записываются только младшие восемь бит. При ошибке записи передаётся исключение.





196. Какой символ является разделителем при указании пути к ЭФС?
\\ /



197. Как выбрать все ЭФС определенного каталога по критерию (например, с определенным расширением)?
не понятно, возможно использовать FileFilter


198. Что вы знаете об интерфейсе FileFilter?
A filter for abstract pathnames.
Instances of this interface may be passed to the listFiles(FileFilter) method of the File class.


199. Что такое сериализация?
Во время сериализации, также как и transient переменные, статические поля не сериализуются. Действительно, если сохранить любые данные в статическом поле,
то после десериализации новый объект будет содержать его первичное (по-умолчанию) значение, например, если статическим полем была переменная типа int, то её значение после десериализации будет равно нулю, 
если типа float – 0.0, если типа Object – null. Честно говоря, это один из наиболее часто задаваемых вопросов касательно сериализации на собеседованиях по Java. 
Не храните наиболее важные данные об объекте в статическом поле!



200. Какие условия “благополучной” сериализации объекта?
Для начала следует убедиться, что класс сериализуемого объекта реализует интерфейс java.io.Serializable
Интерфейс Serializable это интерфейс-маркер; в нём не задекларировано ни одного метода. Но говорит сериализующему механизму, что класс может быть сериализован.
Так делается сериализация.
public static void main(String args[]) throws IOException {
  FileOutputStream fos = new FileOutputStream("temp.out");
  ObjectOutputStream oos = new ObjectOutputStream(fos);
  TestSerial ts = new TestSerial();
  oos.writeObject(ts);
  oos.flush();
  oos.close();
}
Так делается десериализация
public static void main(String args[]) throws IOException {
  FileInputStream fis = new FileInputStream("temp.out");
  ObjectInputStream oin = new ObjectInputStream(fis);
  TestSerial ts = (TestSerial) oin.readObject();
  System.out.println("version="+ts.version);
}
Если какой-либо объект действует как ссылка на другой объект, то поля этого объекта также сериализованны, если класс этого объекта реализует интерфейс Serializable. 
Другими словам, получаемый таким образом граф этого объекта, сериализуем полностью. Граф объекта включает дерево или структуру полей объекта и его подобъектов.



201. Какие классы позволяют архивировать объекты?
JarOutputStream,ZipOutputStream
JarInputStream,ZipInputStream - разархивировать

Для хранения классов языка Java и связанных с ними ресурсов в языке Java
используются сжатые архивные jar-файлы.
Для работы с архивами в спецификации Java существуют два пакета –
java.util.zip и java.util.jar соответственно для архивов zip и jar.
Различие форматов jar и zip заключается только в расширении архива zip. Па-
кет java.util.jar аналогичен пакету java.util.zip, за исключением реа-
лизации конструкторов и метода void putNextEntry(ZipEntry e) класса
JarOutputStream. Ниже будет рассмотрен только пакет java.util.jar.
Чтобы переделать все примеры на использование zip-архива, достаточно всюду
в коде заменить Jar на Zip
JarOutputStream jos =
new JarOutputStream(
new FileOutputStream(jarFileName));
// метод сжатия
jos.setLevel(Deflater.DEFAULT_COMPRESSION);
for (int i = 0; i < filesToJar.length; i++) {
System.out.println(i);
jos.putNextEntry(new JarEntry(filesToJar[i]));
FileInputStream in =
new FileInputStream(filesToJar[i]);
int len;
 while ((len = in.read(buffer)) > 0)
jos.write(buffer, 0, len);
jos.closeEntry();
in.close();
}
jos.close();
import java.io.*;
import java.util.zip.*;

public class SaveEmployee {

    public static void main(String argv[]) throws
            Exception {
        Employee sarah = new Employee("S. Jordan", 28,
                56000);
        Employee sam = new Employee("S. McDonald", 29,
                58000);
        FileOutputStream fos = new FileOutputStream("db");
        GZIPOutputStream gz = new GZIPOutputStream(fos);
        ObjectOutputStream oos = new ObjectOutputStream(gz);
        oos.writeObject(sarah);
        oos.writeObject(sam);
        oos.flush();
        oos.close();
        fos.close();
    }
}






Потоки выполнения/многопоточность (оглавление)

202. Дайте определение понятию “процесс”.
Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство. Чаще всего одна программа состоит из одного процесса, 
но бывают и исключения (например, браузер Chrome создает отдельный процесс для каждой вкладки, что дает ему некоторые преимущества, вроде независимости вкладок друг от друга).
 Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен (взаимодействие между процессами осуществляется с помощью специальных средств).

203. Дайте определение понятию “поток”.
Один поток – это одна единица исполнения кода. Каждый поток последовательно выполняет инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.
Следует отдельно обговорить фразу «параллельно с другими потоками». Известно, что на одно ядро процессора, в каждый момент времени, приходится одна единица исполнения. 
Каждый процесс имеет хотя бы один выполняющийся поток. Тот поток, с которого начинается выполнение программы, называется главным.
 В языке Java, после создания процесса, выполнение главного потока начинается с метода main(). Затем, по мере необходимости, 
в заданных программистом местах, и при выполнении заданных им же условий, запускаются другие, побочные потоки.


204. Дайте определение понятию “синхронизация потоков”.
Синхронизация относится к многопоточности. Синхронизированный блок кода может исполняться одновременно только одним потоком. 
Java позволяет обрабатывать одновременно несколько потоков. Это может привести к тому, что два или более потока хотят получить доступ к одному и тому же полю. 
Синхронизация позволяет избежать ошибок памяти, возникающих при неправильном использовании ресурсов памяти. Когда метод объявлен как синхронизированный, нить удерживает его монитор.
 Если другая нить пытается в это время получить доступ к синхронизированному методу, то поток блокируется, и ждет освобождения монитора. 
Синхронизация в Java осуществляется специальным ключевым словом synchronized. Вы можете помечать таким образом отдельные блоки или методы в вашем классе.
 Ключевое слово synchronized не может быть использовано вместе с переменными или атрибутами класса.

Итак, резюме. Если два нестатических метода объявлены как synchronized, то в каждый момент времени из разных потоков на одном объекте может быть вызван только один из них. 
Поток, который вызывает метод первым, захватит монитор, и второму потоку придется ждать. Заостряю ваше внимание на трех моментах:
---Это верно только для разных потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него – другой синхронизированный метод на том же экземпляре. 
    Поскольку этот поток владеет монитором, проблем второй вызов не создаст.

---Это верно только для вызовов методов одного экземпляра. У разных экземпляров разные мониторы, потому одновременный вызов нестатических методов проблем не создаст

---В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы, или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса.



205. Как взаимодействуют программы, процессы и потоки?
см выше


206. В каких случаях целесообразно создавать несколько потоков?
Для чего это нужно. Современное ПО по большей часто асинхронно. Приложение ждет реакции пользователя, приложение ждет прихода данных по сети, приложение ждет готовности устройства. 
Приложение ждет. Если вы посмотрите на загрузку процессора, то увидите, что чаще всего 99% времени он простаивает. Соответственно, пока одна задача находится в стадии ожидания, можно заниматься другой.
Например, во время ожидания прихода данных по сети можно отрисовать то, что уже пришло. Это если говорить о браузере. Да и вообще, в ОС одновременно происходит множество разных событий. 
Когда есть несколько задач разных. Которые нужно выполнять одновременно. 



207. Что может произойти если два потока будут выполнять один и тот же код в программе?
Ошибки памяти, возникающих при неправильном использовании ресурсов памяти.
Или например, когда в одном потоке выполняется запись информации в файл, второму потоку должно быть запрещено делать это в тот же самый момент времени.


208. Что вы знаете о главном потоке программы?
При запуске программы операционная система создает процесс, загружая в его адресное пространство код и данные программы, а затем запускает главный поток созданного процесса.
Это поток, от которого порождаются все "дочерние" потоки.
Часто он должен быть последним потоком, завершающим выполнение, так как он предпринимает различные завершающие действия.
Несмотря на то что главный поток создается автоматически при запуске программы, им можно управлять через объект Thread. 
Чтобы делать это, вы должны получить ссылку на него вызовом метода current-Thread (), который является общедоступным статическим (public static) методом класса Thread. Его общая форма выглядит следующим образом:
static Thread currentThread ()
Этот метод возвращает ссылку на поток, из которого он был вызван. Получив ссылку на главный поток, вы можете управлять им точно так же, как любым другим. 



209. Какие есть способы создания и запуска потоков?
В основу системы многопоточной обработки в Java положены класс Thread и интерфейс Runnable, входящие в пакет java. lang. Класс Thread инкапсулирует поток исполнения. 
Для того чтобы образовать новый поток, нужно создать класс, являющийся подклассом Thread или реализующий интерфейс Runnable.
В классе Thread определен ряд методов, позволяющих управлять потоками. Некоторые из этих наиболее употребительных методов описаны ниже. 
По мере их представления в последующих примерах программ вы ознакомитесь с ними поближе.

Метод	Описание
final String getName()	Получает имя потока
final int getPriority()	Получает приоритет потока
final boolean isAliveO	Определяет, выполняется ли поток
final void join()	Ожидает завершения потока
void run()	Определяет точку входа в поток
static void sleep(long миллисекунд)	Приостанавливает исполнение потока на указанное число миллисекунд
void start()	Запускает поток, вызывая его метод run()

Для того чтобы создать поток, нужно построить объект типа Thread. Класс Thread инкапсулирует объект, который может стать исполняемым. 
Как пояснялось ранее, пригодные для исполнения объекты можно создавать в Java двумя способами:
1.реализуя интерфейс Runnable;
2. создавая подкласс класса Thread.
Но независимо от выбранного способа создание экземпляра потока, организация доступа к нему и управление потоком осуществляется средствами класса Thread.
 Единственное отличие обоих способов состоит в том, как создается класс, активизирующий поток.
Интерфейс Runnable дает абстрактное описание единицы исполняемого кода. Для формирования потока подходит любой объект, реализующий этот интерфейс. В интерфейсе Runnable объявлен только один метод, run():
public void run()

// Создание потока путем реализации интерфейса Runnable,
class MyThread implements Runnable {
    String thrdName;

    // Объекты типа MyThread выполняются в отдельных потоках, так как
    // класс MyThread реализует интерфейс Runnable.
    MyThread(String name) {
        thrdName = name;
    }

    // Точка входа в поток,
    public void run() {
        // Здесь начинают исполняться потоки.
        System.out.println(thrdName + " starting.");
        try {
            for(int count=0; count < 10; count++) {
                Thread.sleep(400);
                System.out.println("In " + thrdName +
                                   ", count is " + count);
            }
        }
        catch(InterruptedException exc) {
            System.out.println(thrdName + " interrupted.");
        }
        System.out.println(thrdName + " terminating.");
    }
}

class UseThreads {
    public static void main(String args[]) {
        System.out.println("Main thread starting.");
        // сначала построить объект типа MyThread
        MyThread mt = new MyThread("Child #1"); // Создание исполняемого объекта.
        // далее сформировать поток из этого объекта
        Thread newThrd = new Thread(mt); // Формирование потока из этого объекта.
        // и, наконец, начать исполнение потока

        newThrd.start О; // Начало исполнения потока.
        for(int i=0; i<50; i++) {
            System.out.print(".") ;
            try {
                Thread.sleep(100) ;
            }
            catch(InterruptedException exc) {
                System.out.println("Main thread interrupted.");
            }
        }
        System.out.println("Main thread ending.");
    }
}

// Создание второго потока
class NewThread extends Thread {
	// Конструктор
	NewThread() {
		// Создаём новый второй поток
		super("Второй поток");
		System.out.println("Создан второй поток " + this);
		start(); // Запускаем поток
	}

	// Точка входа второго потока
	public void run() {
		try {
			for (int i = 5; i > 0; i--) {
				System.out.println("Второй поток: " + i);
				Thread.sleep(500);
			}
		} catch (InterruptedException e) {
			System.out.println("Второй поток прерван");
		}
		System.out.println("Второй поток завершён");
	}
}



210. Какой метод запускает поток на выполнение?
Thread.start()



211. Какой метод описывает действие потока во время выполнения?
Thread.run()


212. Когда поток завершает свое выполнение?
когда закончится выполнятся метод run



213. Как синхронизировать метод?
Синхронизировать код можно двумя способами. Оба способа рассматриваются ниже, и в обоих используется ключевое слово synchronized.
1.Для того чтобы синхронизировать метод, в его объявлении следует указать ключевое слово synchronized. Когда такой метод получает управление,
 вызывающий поток активизирует монитор, что приводит к блокированию объекта. Если объект блокирован, он недоступен из другого потока, а кроме того,
 его нельзя вызвать из других синхронизированных методов, определенных в классе данного объекта. Когда выполнение синхронизированного метода завершается, монитор разблокирует объект, 
что позволяет другому потоку использовать этот метод. Таким образом, для достижения синхронизации программирующему на Java не приходится прилагать каких-то особых усилий.

2.Синхронизированный блок определяется следующим образом:

synchronized{ссылка_на_объект) {
    // синхронизируемые операторы
}
где ссылканаобъект обозначает ссылку на конкретный объект, который должен быть синхронизирован. Как только содержимое синхронизированного блока получит управление, 
ни один другой поток не сможет вызвать метод для объекта, на который делается ссылканаобъект9 до тех пор, пока этот кодовый блок не завершится.




214. Как принудительно остановить поток?
есть еще метод interrupt()
 Предлагается, безусловно, очень безопасная инструкция Thread.interrupt(). Но безопасна она, к сожалению, потому, что ровным счетом ничего не делает! Это всего лишь сообщение потоку: «Пожалуйста, остановись».
 Но если поток данное сообщение проигнорировал то… как сказано в документации «Если поток не отвечает на Thread.interrupt() вы можете использовать специфические для вашего приложению трюки». 
Спасибо, что разрешили. Что называется, крутись как хочешь.
На данный момент мы знаем, как запустить поток на выполнение. Естественный вопрос – а как его остановить? Ответ может оказаться обескураживающим. 
В Java НЕТ средств для принудительной остановки потока. Вернее, они есть, но использовать их не стоит – метод stop объявлен deprecated. А вместе с ним – и suspend c resume.


215. Дайте определение понятию “поток-демон”.
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. 
Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, 
то такой процесс может быть запущен как поток-демон.
Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. 
Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.



216. Как создать поток-демон?
 С помощью метода setDaemon(boolean value), вызванного вновь созданным потоком до его запуска, можно определить поток-демон.
 Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет.



217. Как получить текущий поток?
public static Thread currentThread()
Returns a reference to the currently executing thread object.




218. Дайте определение понятию “монитор”.
Главным для синхронизации в Java является понятие монитора, контролирующего доступ к объекту. Монитор реализует принцип блокировки. 
Если объект заблокирован одним потоком, то он оказывается недоступным для других потоков. В какой-то момент объект разблокируется, и другие потоки могут обращаться к нему.
У каждого объекта в Java имеется свой монитор. Этот механизм встроен в сам язык. Следовательно, все объекты поддаются синхронизации. 
Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора.
Монитор экземпляра может иметь только одного владельца. При попытке кон-
курирующего доступа к объекту, чей монитор имеет владельца, желающий за-
блокировать объект-ресурс поток должен подождать освобождения монитора
этого объекта и только после этого завладеть им и начать использование объек-
та-ресурса. Каждый экземпляр любого класса имеет монитор. 


219. Как приостановить выполнение потока?
Поток следует разрабатывать таким образом, чтобы в методе run() периодически осуществлялась проверка, следует ли приостановить, возобновить или остановить поток. О
бычно для этой цели используются две флаговые переменные: одна — для приостановки и возобновления потока, другая — для остановки потока. Если флаговая переменная, 
управляющая приостановкой потока, установлена в состояние исполнения, то метод run() должен обеспечить продолжение исполнения потока. Если же эта флаговая переменная находится в состоянии приостановки,
 в работе потока должна произойти пауза. А если переменная, управляющая остановкой потока, находится в состоянии остановки, исполнение потока должно прекратиться.
1. Есть метод sleep(long millis) в классе Thread
2. Есть метод wait(), но он освобождает монитор.



220. В каких состояниях может пребывать поток?
Поток может находиться в одном из нескольких состояний. 
----В целом поток может быть выполняющимся; 
----готовым к выполнению, как только он получит время и ресурсы ЦП; 
----приостановленным, т.е. временно не выполняющимся; 
----возобновленным в дальнейшем; 
----заблокированным в ожидании ресурсов для своего выполнения; 
----а также завершенным, когда его выполнение окончено и не может быть возобновлено.


221. Что является монитором при вызове нестатического и статического метода?
--Статический метод захватывает монитор экземпляра класса Class, того класса, на котором он вызван. Существует в единственном экземпляре. 
--Нестатический метод захватывает монитор экземпляра класса, на котором он вызван.


222. Что является монитором при выполнении участка кода метода?
Object sync = new Object();
...
synchronized(sync){

}
В этом случае (синхронизация блока) захватывается монитор у объекта sync. 


223. Какие методы позволяют синхронизировать выполнение потоков?
Методы wait(), notify() и notifyAll()
Эти методы используются для управления потоками в ситуации, когда
необходимо задать определенную последовательность действий без повторного
запуска потоков.
Метод wait(), вызванный внутри синхронизированного блока или метода,
останавливает выполнение текущего потока и освобождает от блокировки за-
хваченный объект. Возвратить блокировку объекта потоку можно вызовом ме-
тода notify() для одного потока или notifyAll() для всех потоков. Если ожидаю-
щих потоков несколько, топосле вызова метода notify()невозможно определить,
какой поток из ожидающих потоков заблокирует объект. Вызов может быть
осуществлен только из другого потока, заблокировавшего в свою очередь
тот же самый объект.



224. Какой метод переводит поток в режим ожидания?
wait()

225. Какова функциональность методов notify и notifyAll?
Возвратить блокировку объекта потоку можно вызовом ме-
тода notify() для одного потока или notifyAll() для всех потоков. Если ожидаю-
щих потоков несколько, топосле вызова метода notify()невозможно определить,
какой поток из ожидающих потоков заблокирует объект. Вызов может быть
осуществлен только из другого потока, заблокировавшего в свою очередь
тот же самый объект.



226. Что позволяет сделать метод join?
Тут все намного проще. Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.
 Это удобно во многих случаях. Например, запустили мы чтение данных в отдельном потоке и занялись подготовкой инфраструктуры для их обработки. 
Закончили подготовку – а данные еще не готовы. Вот тогда можно подождать окончания потока, в котором они читаются.

Кстати, с этим методом связан очень любопытный прием.
Так вот, при работе с сетевыми соединениями не всегда можно указать таймаут. В частности, при использовании java.net.URL. С версии 1.5 у java.net.URLConnection 
уже появились методы setConnectTimeout и setReadTimeout, но до нее такого способа не было. И, соответственно, бывали случаи, 
когда вызов connect у URLConnection блокировал поток всерьез и надолго.
Предложеное решение оказалось весьма оригинальным.
URL url = new URL(...)
final URLConnection connection = url.openConnection();
// connection initialization
long timeout = 5000;
Thread t = new Thread(new Runnable(){
    public void run(){
        connection.connect();
    }
});
t.start();
t.join(timeout);

//если бы был метод t.join(); то ждал бы до конца, а не 5 секунд.
 


227. Каковы условия вызова метода wait/notify?
Пожалуй, это наиболее часто использующийся тип синхронизации. Суть его проста. Берется некий объект. Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, 
предварительно захватив его монитор. На этом его работа приостанавливается. 
Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта), в результате чего, 
ждущий на объекте поток "просыпается" и продолжает свое выполнение. Подчеркиваю, в обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, 
ибо методы семейства wait/notify не синхронизированы! Для меня загадка, почему это так, но примем как данность.





228. Дайте определение понятию “взаимная блокировка”.
Что такое взаимная блокировка по своей сути? Все достаточно просто. Предположим, что один поток уже захватил монитор на некотором объекте x и для продолжения работы ему нужно захватить монитор на объекте y. 
В другом же потоке ситуация ровно обратная – он уже захватил монитор на объекте y и ему нужен монитор объекта x. В результате оба потока будут ждать, пока нужный монитор освободится. 
Как вы сами прекрасно понимаете, ждать они будут до бесконечности. Эта ситуация и называется взаимной блокировкой – deadlock.



229. Чем отличаются методы interrupt, interrupted, isInterrupted?
Вариант первый – использовать существующий механизм. У класса Thread есть такой метод – interrupt. Этот метод выставляет некоторый флаг в дебрях native-кода. 
В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted. Существует также статический метод interrupted, который производит проверку для текущего потока. 
Обратите внимание – вызов этого метода сбрасывает флаг, что подразумевает ответственность разработчика по обработке этой ситуации.




230. В каком случае будет выброшено исключение InterruptedException, какие методы могут его выбросить?
Что хорошо в методе interrupt? Он способен вывести поток из состояния ожидания. Т.е. если у потока были вызваны методы sleep или wait (мы поговорим о нем ниже) – ожидание прервется и будет 
выброшено исключение InterruptedException. Флаг в этом случае не выставляется, т.к. на брошеное исключение разработчик отреагирует незамедлительно.

Таким образом, действовать нужно так. Реализуете поток (удобнее через наследование от Thread). В потоке периодически вставляете проверки isInterrupted.
 Если проверка сработала или выброшено исключение во время ожидания – поток пытаются остановить извне. Обращаю внимание – именно остановить, а не ПРИостановить. 
Вам надо принять решение – либо вы продолжаете работу (если по каким-то причинам не можете остановиться), либо вы освобождаете ресурсы и выходите из метода run. 
Что вы выберете – зависит от ситуации. Главное – у вас есть возможность маневрировать и делать то, что сочтете нужным. В том числе и продолжать работу.



231. Модификаторы synchronized и volatile
volatile проще, нежели синхронизация и подходит только для контроля доступа к одиночному экземпляру или переменной примитивного типа: 
int, boolean... Когда переменная объявлена как volatile, любая запись её будет осуществляться прямо в память, минуя кеш. Также как и считываться будет прямо из памяти,
 а не из всевозможного кеша. Это значит, что все потоки будут "видеть" одно и то же значение переменной одновременно.
synchronized - это взаимное исключение и видимость изменений


232. Пакет java.util.concurrent
Ссылка - http://habrahabr.ru/company/luxoft/blog/157273/
Cодержит высокопроизводительные, потокобезопасные реализации для рабочих типов коллекций List и Map.
Состоит из частей:
1.Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. 
Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа 
для параллельного чтения данных по wait-free алгоритмам.
2.Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. 
Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, 
очередь пуста или перепонена, или же нет свободного «Consumer»'a.
3.Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.
4.Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. 
5. Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
6. Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.


233. Какие вы знаете способы запустить некоторое действие в отдельном потоке?
Существует два пути создания потока. Первый – наследование от класса java.lang.Thread и переопределение его метода run. Второй – реализация интерфейса java.lang.Runnable и создание потока на основе этой реализации. 



234. Какие вы знаете способы прекратить выполнение потока?
Вариант первый – использовать существующий механизм. У класса Thread есть такой метод – interrupt. Этот метод выставляет некоторый флаг в дебрях native-кода. 
В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted. Существует также статический метод interrupted, который производит проверку для текущего потока. 
Обратите внимание – вызов этого метода сбрасывает флаг, что подразумевает ответственность разработчика по обработке этой ситуации.
Кстати, если вам придется прерывать поток извне – это один из немногих случаев когда удобнее унаследоваться от Thread. Если у вас будет ссылка на экземпляр Thread, 
вызвать у него interrupt не составит труда. Если же вы будете держать ссылку на экземпляр Runnable – придется в начале метода run сохранять ссылку на связаный с этим Runnable поток, 
реализовывать метод для получения этой ссылки и т.п. В общем, много ненужной возни.
Что хорошо в методе interrupt? Он способен вывести поток из состояния ожидания. Т.е. если у потока были вызваны методы sleep или wait (мы поговорим о нем ниже) – 
ожидание прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется, т.к. на брошеное исключение разработчик отреагирует незамедлительно.
Таким образом, действовать нужно так. Реализуете поток (удобнее через наследование от Thread). В потоке периодически вставляете проверки isInterrupted. 
Если проверка сработала или выброшено исключение во время ожидания – поток пытаются остановить извне. Обращаю внимание – именно остановить, а не ПРИостановить. 
Вам надо принять решение – либо вы продолжаете работу (если по каким-то причинам не можете остановиться), либо вы освобождаете ресурсы и выходите из метода run. 
Что вы выберете – зависит от ситуации. Главное – у вас есть возможность маневрировать и делать то, что сочтете нужным. В том числе и продолжать работу. В случае вызова stop такой возможности нет.
Возможная проблема, которую я сейчас вижу в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных (из какого-либо наследника InputStream или Reader) – 
вызов interrupt его из этого состояния не выведет. Решение тут различается в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна. 
И тогда можно просто дождаться выхода из метода read. Если же чтение каким-то образом связано с сетью – можно использовать неблокирующий ввод-вывод (Java NIO).
Пара слов по поводу NIO. Официальной информации по этой технологии сейчас немного, во всяком случае внятного руководства я не нашел. Есть какое-то количество примеров вот тут – http://java.sun.com/j2se/1.4/nio/index.html. 
Есть также очень хорошая книга – Ron Hitchens. Java NIO. ISBN: 0-596-00288-2. Правда, на английском, для кого-то это может быть минусом. Книга эта есть у меня в формате PDF, желающим могу послать по почте.
Второй вариант реализации метода остановки (а также и приостановки) – сделать аналог interrupt, но руками. Т.е. организовать в собственной реализации потока флаги – на остановку и приостановку, – 
и выставлять их путем вызова методов извне. Методика действия та же – проверять установку флагов.
Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не расшевелить. И это серьезный минус по сравнению с первым методом. А во-вторых, выставление флага одним потоком совсем не означает,
 что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, 
в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени. Можно, конечно, объявить эту переменную volatile, 
но это поможет только в случае примитивных типов данных. Подробнее этого вопроса мы коснемся ниже.
В связи со всем вышесказаным, я рекомендую использовать существующий механизм, основаный на выставлении native-флага и использовании метода interrupt. Он намного удобнее и функциональнее.


235. Какие ключевые слова Java, связанные с многопоточностью Вы знаете?
volatile,synchronized


236. Есть некоторый метод, который исполняет операцию i++. Переменная i типа int. Предполагается, что код будет исполнятся в многопоточной среде. Следует ли синхронизировать блок?
Да, блок следует синхронизировать даже если переменная будет volatile(на тот случай если изменения будут храниться в локальном кеше процессора)


237. Что служит в качестве mutex, если метод объявлен synchronized?
 synchronized (mutex) { //mutex - это то что в скобках.
}
--Статический метод захватывает монитор экземпляра класса Class, того класса, на котором он вызван. Существует в единственном экземпляре. 
--Нестатический метод захватывает монитор экземпляра класса, на котором он вызван.



238. Можно ли вызвать в разных потоках два synchronized метода одного и того же объекта?
Каждый объект в java содержит некий внутренний объект простой блокировки, также называемый монитором. При вызове любого синхронизированного метода (syncronized) объект переходит в состояние блокировки 
до тех пор пока этот метод не закончит свою работу и не снимет блокировку, другие synchronized методы для объекта не могут быть вызваны.
Также существут отдельный объект блокировки для класса(монитор для класса), который следит за тем ,чтобы статические synchronized методы не использовали одновременоо общие статические данные класса.
Таким образом в разных потоках два synchronized метода одного и того же объекта вызвать нельзя.


239. Что используется в качестве mutex, если метод объявлен static synchronized? Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?
--Статический метод захватывает монитор экземпляра класса Class, того класса, на котором он вызван. Существует в единственном экземпляре. 
Можно создавать.

240. Объясните, что такое deadlock? Приведите пример кода, который демонстрирует deadlock.
 Предположим, что один поток уже захватил монитор на некотором объекте x и для продолжения работы ему нужно захватить монитор на объекте y. 
В другом же потоке ситуация ровно обратная – он уже захватил монитор на объекте y и ему нужен монитор объекта x. В результате оба потока будут ждать, пока нужный монитор освободится. 
Как вы сами прекрасно понимаете, ждать они будут до бесконечности. Эта ситуация и называется взаимной блокировкой – deadlock.
class Entity {
        public synchronized void method1(Entity entity) {
                entity.method2(this);
        }

        public synchronized void method2(Entity entity) {}

        public static void main(String[] args) {
                Entity en1 = new Entity();
                Entity en2 = new Entity();

                new Thread(new Runnable() {
                        public void run() {
                                en1.method1(en2);
                        }
                }).start();

                new Thread(new Runnable() {
                        public void run() {
                                en2.method1(en1);
                        }
                }).start();
        }
}




241. Какие особенности использования метода wait? При каких условиях поток может выйти из режима ожидания?
Если задан параметр/параметры, определяющий время и если поток не будет разбужен в течении этого времени при помощи методов notify() или notifyAll(), тогда он будет разбужен по прошествии указанного времени.
Если не задан параметр/параметры, определяющие время, то поток будет разбужен только при помощи методов notify() или notifyAll().



242. Предположим в методе run возник RuntimeException, который не был пойман. Что случится с потоком? --- Поток будет остановлен. 
 Есть ли способ узнать о том, что Exception произошел (не заключая все тело run в блок try-catch)?    --- Нет. 
Есть ли способ восстановить работу потока после того как это произошло?                               --- Нет.  


243. Какие стандартные инструменты Java вы бы использовали для реализации пула потоков?
LinkedList, synchronized, wait(), notify()/notifyAll()




SQL, JDBC (оглавление)


244. ANSI SQL -  В 1986 году первый стандарт языка SQL был принят ANSI (American National Standards Institute).


245. Основные элементы баз данных – таблицы, процедуры, функции, констрейнты и т.д.
Констрейнт - ограничение ссылочной целостности,либо объявление первичного ключа.
Внешний ключ также является ограничением CONSTRAINT и отображает связь между двумя таблицами. 
Внешний ключ может ссылаться только на первичный ключ другой таблицы или на ограничение уникальности. Это значит, что после ключевого слова REFERENCES должно быть имя таблицы 
и в скобках можно указывать только первичный ключ или поле с ограничением UNIQUE. Другие поля указывать нельзя.

246. Констрейнты: как вы понимаете null в базах данных.
null - это когда нет данных в поле.
При создании первичного ключа, необходимо еще также накладывать дополнительное ограничение ссылочной целостности на домены, входящие в первичный ключ NOT NULL. Подробнее, см. CREATE DOMAIN


247. Агрегатные функции, как они работают с null. Не забудьте о group by и having
Агрегатные функции - Avg,min,max,count
Агрегатные функции выполняют вычисление на наборе значений и возвращают одиночное значение. Агрегатные функции, за исключением COUNT, не учитывают значения NULL.
 Агрегатные функции часто используются в выражении GROUP BY инструкции SELECT.
Агрегатные функции могут быть использованы в качестве выражений только в следующих случаях.
--Список выбора инструкции SELECT (вложенный или внешний запрос).
--Предложение HAVING.
 предложение HAVING применяется после группировки для определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций.
 Это предложение необходимо для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, 
 а из групп таких строк. Поэтому такая проверка не может содержаться в предложении WHERE.
SELECT model, COUNT(model) AS Qty_model, 
   AVG(price) AS Avg_price
FROM PC
GROUP BY model
HAVING AVG(price) < 800;


248. JDBC: Connection, Statement, PreparedStatement, CallableStatement, ResulSet, зачем каждая из этих сущностей нужна. Чем они являются: абстрактными классамм, конкретными классами или интерфейсами и почему.
В JDBC есть три класса для посылки SQL-запросов в БД и три метода в интерфейсе Connection создают экземпляры этих классов. Эти классы и методы, которые их создают, перечислены ниже:
Statement - создается методом createStatement. Объект Statement используется при простых SQL-запросах.
PreparedStatement - создается методом prepareStatement. Объект PreparedStatement используется в SQL-запросах с одним или более входными параметрами (IN parameters). PreparedStatement содержит группу методов,
 устанавливающих значения входных параметров, которые отсылаются в БД при выполнении запроса. Экземпляры класса PreparedStatement расширяют (наследуются от) Statement и, таким образом, включают методы Statement.
 Объект PreparedStatement потенциально может быть более эффективным, чем Statement, так как он прекомпилируется и сохраняется для будущего использования.
CallableStatement - создается методом prepareCall. Объекты CallableStatement используются для выполнения т.н. хранимых процедур - именованных групп SQL-запросов, наподобие вызова подпрограммы.
 Объект CallableStatement наследует методы обработки входных (IN) параметров из PreparedStatement, а также добавляет методы для обработки выходных (OUT) и входных-выходных (INOUT) параметров.

Нижеследующий список дает представление о том, какой именно из методов объекта Connection лучше использовать для создания различных SQL-запросов:

Метод createStatement используется для простых SQL-выражений (без параметров)

Метод prepareStatement используется для SQL-выражений с одним или более входным (IN-) параметром или простых SQL-выражений, которые исполняются часто 

Метод prepareCall используется для вызова хранимой процедуры

это все интерфейсы

    public List<LabelValue> getAllProductsAsLabelValue(WebDTO webDTO){
        if(webDTO == null){
            return null;
        }
        PreparedStatement preparedStatement = null;
        ResultSet rs = null;
        Connection connection = Connections.getJNDIConnection();
        try {
            StringBuilder sqlClause = new StringBuilder(SELECT_ALL_PRODUCTS_LIKE_LABEL_VALUE);
            String cityUid = webDTO.getCityUid();


            preparedStatement = connection.prepareStatement(sqlClause.toString());
            preparedStatement.setString(1,cityUid);


            rs = preparedStatement.executeQuery();
            List<LabelValue> result = null;

            if (rs != null) {
                result = new ArrayList<LabelValue>();
                while (rs.next()) {
                    LabelValue model = new LabelValue();
                    String value = rs.getString("value");
                    model.setValue(value);
                    model.setLabel(value +"; " + rs.getString("label"));
                    result.add(model);
                }
            }
            return result;
        } catch (SQLException e) {
            log.error("Failed to execute a query", e);
            e.printStackTrace();
        } finally {
            closeAfterRaw(connection, preparedStatement, rs, log);
        }
        return null;
    }




249. Как создать соединение в JDBC?
 public static Connection getJNDIConnection(){
      try {
          String DATASOURCE_CONTEXT = "java:comp/env/jdbc/TeplopolDataSource";

          try {
            Context initialContext = new InitialContext();
            if ( initialContext == null){
              log("JNDI problem. Cannot get InitialContext.");
            }
            DataSource datasource = (DataSource)initialContext.lookup(DATASOURCE_CONTEXT);
            if (datasource != null) {
                Connection connection = datasource.getConnection();
                return connection;
            }
            else {
              log("Failed to lookup datasource.");
            }
          }
          catch ( NamingException ex ) {
            log("Cannot get connection: " + ex);
          }
          catch(SQLException ex){
            log("Cannot get connection: " + ex);
          }
      } catch (Exception e) {
          e.printStackTrace();
      }
      return null;
  }



250. Каким образом лучше добавлять большое количество записей в таблицу?
INSERT INTO
    `tbl_name` (`field1`, `field2`)
VALUES
    (4, `field1`*`field1`)
либо
INSERT INTO
    `users_new`
SELECT
    *
FROM
    `users`
WHERE
    `country` = 'Russia'





251. Транзакции и autocommit
Транзакция состоит из одного или более выражений, которые поле выполнения либо все фиксируются (commit), либо все откатываются назад (rollback). 
При вызове метода commit или rollback текущая транзацкия заканчивается и начинается другая.
Каждое новое соединение по умолчанию находится в режиме автофиксации (auto-commit), что означает автоматическую фиксацию (commit) транзакции после каждого запроса. 
В этом случае транзакция состоит из одного запроса. Если auto-commit запрещен, транзакция не заканчивается вплоть до явного вызова commit или rollback, включая, таким образом, 
все выражения, выполненные с момента последнего вызова commit или rollback. В этом случае все SQL-запросы в транзакции фиксируются или откатываются группой.
Метод фиксации commit делает окончательными все изменения в БД, проделанные SQL-выражением, и снимает также все блокировки, установленные транзакцией. Метод rollback проигнорирует, "отбракует" эти изменения.
Иногда пользователю нужно, чтобы какое-либо изменение не вступило в силу до тех пор, пока не вступит в силу предыдущее изменение. Этого можно достичь запрещением auto-commit и группировкой обоих запросов в одну транзакцию. 
Если оба изменения произошли успешно, то вызывается метод commit, который переносит эффект от этих изменений в БД; если одно или оба запроса не прошли, то вызывается метод rollback, который возвращает прежнее состояние БД.
Большинство JDBC-драйверов поддерживают транзакции. На самом деле драйвер, соответствующий спецификации JDBC, обязан поддерживать их. 
Интерфейс DatabaseMetaData предоставляет информацию об уровнях изолированности транзакций, которые поддерживаются данной СУБД.
try
{
conn.setAutoCommit (false);
Statement s = conn.createStatement ();
// передать деньги от одного человека другому
s.executeUpdate ("UPDATE money SET amt = amt - 6 WHERE name = 'Eve'");
s.executeUpdate ("UPDATE money SET amt = amt + 6 WHERE name = 'Ida'");
s.close ();
conn.commit ();
conn.setAutoCommit (true);
}
catch (SQLException e)
{
System.err.println ("Transaction failed, rolling back.");
Cookbook.printErrorMessage (e);
// пустой обработчик исключений, если откат не удался
try
{
conn.rollback ();
conn.setAutoCommit (true);
}
catch (Exception e2) { }
}


JTA представляет собой аббревиатуру Java Transaction API. Это API позволяет разграничить транзакции способом, независящим от реализации менеджера транзакций. 
J2EE SDK реализует менеджер транзакций при помощи Java Transaction Service (JTS). Но в коде эти методы не вызываются прямо. Вместо этого, вызываются JTA-методы, которые, в свою очередь, вызывают JTS-процедуры низкого уровня.
JTA-транзакции управляются менеджером транзакций J2EE. Вы, вероятно, захотите использовать JTA-транзакцию потому, что она может обновлять нескольких баз данных от разных поставщиков. 
Менеджер транзакций конкретной DBMS может не работать с гетерогенными базами данных. Однако, менеджер транзакций J2EE имеет одно ограничение - он не поддерживает вложенных транзакций. 
Другими словами, он не может начать транзакцию для экземпляра пока предыдущая транзакция не закончится.
Исходный код следующего примера расположен в каталоге j2eetutorial/examples/src/ejb/teller. Чтобы откомпилировать этот код, выполните команду ant teller. 
Для создания таблиц базы данных выполните команду ant create-bank-teller. Файл примера TellerApp.ear находится в каталоге j2eetutorial/examples/ears.
Для того чтобы разграничить транзакцию, нужно вызвать методы begin, commit и rollback интерфейса javax.transaction.UserTransaction. Приведенный ниже код, взятый из класса TellerBean, 
демонстрирует методы UserTransaction. Вызовы begin и commit определяют границы обновлений базы данных. Если обновления заканчиваются неудачно, код вызывает метод roolback и генерирует EJBException.

public void withdrawCash(double amount) {

   UserTransaction ut = context.getUserTransaction();

   try {
      ut.begin();
      updateChecking(amount);
      machineBalance -= amount;
      insertMachine(machineBalance);
      ut.commit();
   } catch (Exception ex) {
       try {
          ut.rollback();
       } catch (SystemException syex) {
           throw new EJBException
              ("Rollback failed: " + syex.getMessage());
       }
       throw new EJBException 
          ("Transaction failed: " + ex.getMessage());
    }
}

Есть несколько способов разрешения конфликтов между одновременно выполняющимися транзакциями. Пользователь может задать уровень изолированности, то есть уровень внимания, 
которое СУБД должна уделить при разрешении возможных конфликтов. Например, что будет, если одна транзакция изменит какое-либо значение, 
а вторая транзакция прочитает его перед тем как первая выполнит commit или rollback? Допустимо ли это, например, если это значение, будучи уже прочитанным второй транзакцией, 
окажется некорректным и будет откатано (rolled back) первой? Пользователь JDBC может указать СУБД на возможность чтения измененных значений до того, как выполнится commit ("грязное чтение", "dirty reads").
 Это делается так (con - это соединение с БД):

con.setTransactionIsolation(TRANSACTION_READ_UNCOMMITTED);
Чем выше уровень изолированности транзакций, тем больше внимания СУБД уделяет устранению конфликтов. Интерфейс Connection определяет пять таких уровней. Минимальный из них соответствует случаю,
 когда транзакции не поддерживаются вовсе, а максимальный - невозможности существования более одной транзакции в любой момент времени. Обычно, чем выше уровень изолированности, 
тем медленнее выполняется приложение (из-за избыточной блокировки и уменьшенной конкурентности пользователей). При выборе конкретного уровня изолированности разработчик должен найти золотую середину 
между потребностями в производительности и требованиями к целостности данных. Очевидно, что реально поддерживаемые уровни зависят от возможностей используемой СУБД.
При создании объекта Connection его уровень изолированности зависит от драйвера или БД. Пользователь может вызвать метод setIsolationLevel, чтобы изменить уровень изолированности транзакций, 
и новое значение уровня будет установлено до конца сессии. Чтобы установить уровень изолированности только для одной транзакции, 
надо установить его перед выполнением транзакции и восстановить прежнее значение после ее завершения. Изменение уровня изолированности во время самой транзакции нежелательно, 
так как произойдет автоматический вызов commit, что повлечет за собой фиксацию изменений.




252. Что такое первая нормальная форма и процесс нормализации? Какие бывают нормальные формы?
Нормальная форма — свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных.
 Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение.
Процесс преобразования отношений базы данных к виду, отвечающему нормальным формам, называется нормализацией. Нормализация предназначена для приведения структуры БД к виду, 
обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных.
[1] Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации. Как отмечает К. Дейт,[2] общее назначение процесса нормализации заключается в следующем:

исключение некоторых типов избыточности;
устранение некоторых аномалий обновления;
разработка проекта базы данных, который является достаточно «качественным» представлением реального мира, интуитивно понятен и может служить хорошей основой для последующего расширения;
упрощение процедуры применения необходимых ограничений целостности.
Устранение избыточности производится, как правило, за счёт декомпозиции отношений таким образом, чтобы в каждом отношении хранились только первичные факты (то есть факты, не выводимые из других хранимых фактов).



253. В чем смысл индекса СУБД, как они устроены, как хранятся? Как бы вы реализовали тот же функционал? Последний вопрос задают в случае, если нет четкого понимания индексов.
Индекс состоит из набора страниц, узлов индекса, которые организованы в виде древовидной структуры — сбалансированного дерева. 
Эта структура является иерархической по своей природе и начинается с корневого узла на вершине иерархии и конечных узлов, листьев, в нижней части, как показано на рисунке:
Когда вы формируете запрос на индексированный столбец, подсистема запросов начинает идти сверху от корневого узла и постепенно двигается вниз через промежуточные узлы, 
при этом каждый слой промежуточного уровня содержит более детальную информацию о данных. Подсистема запросов продолжает двигаться по узлам индекса до тех пор, пока не достигнет нижнего уровня с листьями индекса.
 К примеру, если вы ищете значение 123 в индексированном столбе, то подсистема запросов сначала на корневом уровне определит страницу на первом промежуточном (intermediate) уровне. 
В данном случае первой страница указывает на значение от 1 до 100, а вторая от 101 до 200, таким образом подсистема запросов обратится ко второй странице этого промежуточного уровня. 
Далее будет выяснено, что следует обратиться к третьей странице следующего промежуточного уровня. 


254. Нарисуйте отношение Многие-ко-многим. Например: таблицы Авторы и Книги. У одного автора может быть несколько книг, и книга может быть написана несколькими авторами. Составьте SQL запрос на выборку книг определенного автора.



JSP (оглавление)

255. Что такое jsp и зачем он нужен?
256. Расскажите об этапах жизненного цикла jsp.
257. Расскажите о методах жизненного цикла jsp.
258. Как закомментировать код в jsp?
259. Какие есть способы вставки java кода в jsp страницу?
260. Почему не рекомендуется использовать скриптовые элементы в jsp?
261. Какие неявные, внутренние объекты есть на jsp странице?

262. Что вы знаете о PageContext?
263. Как можно запретить использование скриптов и java кода на jsp странице?
264. Что вы знаете о jsp тегах?
265. Что вы знаете о языке выражений jsp (JSP Expression Language – EL)?
266. Назовите неявные, внутренние объекты JSP EL и их отличия от объектов jsp.
267. Как узнать http метод использую JSP EL?
268. Что такое JSTL (Jsp Standard tag library)?
269. На какие категории можно разделить JSTL теги, приведите примеры.
270. Что вы знаете о написании пользовательских jsp тегов?
271. Как можно обработать ошибки jsp страниц?
272. Как происходит обработка ошибок с помощью jstl?
273. Как деактивировать использование EL на JSP?
274. Можно ли использовать javascript на jsp странице?
275. Всегда ли создается объект сессии на jsp странице, можно ли отключить его создание?
276. Как можно расширить функциональность jsp?




Servlet (оглавление)

277. Какова структура веб-проекта?
278. Что такое сервлет?
279. Что такое контейнер сервлетов?
280. Каковы задачи, функциональность контейнера сервлетов?
281. Что вы знаете о сервлет фильтрах?
282. Зачем нужны слушатели в сервлетах?
283. Когда вы будете использовать фильтры а когда слушатели?
284. Как обработать исключения, выброшенные другим сервлетом в приложении?
285. Что такое дискриптор развертывания?
286. Как реализовать запуск сервлета с запуском приложения?
287. Что представляет собой объект ServletConfig?
288. Что представляет собой объект ServletContext?
289. В чем отличия ServletContext и ServletConfig?
290. Что такое Request Dispatcher?
291. Как можно создать блокировку (deadlock) в сервлете?
292. Как получить адрес сервлета на сервере?
293. Как получить информацию о сервере с сервлета?
294. Как получить ip адрес клиента на сервере?
295. Что вы знаете о классах обертках (wrapper) для сервлетов?
296. Каков жизненный цикл сервлета и когда какие методы вызываются?
297. Какие методы необходимо определить при создании сервлетов?
298. В каком случае вы будете переопределять метод service()?
299. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?
300. В чем отличия GenericServlet и HttpServlet?
301. Как вызватьиз сервлета другой сервлет этого же и другого приложения?
302. Что вы знаете и в чем отличия методов forward() и sendRedirect()?
303. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?
304. Что такое servlet scope (область видимости – время жизни) и какие вы знаете?
305. Что вы знаете и зачем нужны методы java.net.URLEncoder.encode() и decode()?
306. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?




Web (оглавление)

307. Что такое www?
308. Что такое w3c?
309. Что такое TCP/IP?
310. Что такое ftp?
311. Чем отличаются http и https?
312. Что такое протокол передачи данных, какие вы знаете?
313. Что такое web server?
314. Что такое web приложение?
315. Что такое application server?
316. Чем отличаются web server и application server?
317. Какие методы передачи данных вы знаете?
318. Чем отличаются методы get и post?
319. Что такое html?
320. Что такое xml?
321. Что такое css?
322. Что такое MIME type?
323. Что такое cookies?
324. Что такое сессия?
325. Дайте определение понятиям “авторизация” и “аутентификация”, в чем их различия?
326. Что такое Ajax? Как принципиально устроена эта технология?
327. Что такое ORM, как это перевести и как это должно работать?











328
Начиная с Java SE 5 типы возвращаемых результатов из методов ковариантны (covariant). Это означает, что мы можем в перекрытом методе (overriden) в качестве типа результата использовать подтип результата перекрываемого метода.

class Covariance implements Cloneable {
	@Override
	public Covariance clone() {
		Object cloned = null;
		try {
			cloned = super.clone();
		} catch (CloneNotSupportedException exc) {
			// В данном примере недостижимо.
		}
		return (Covariance)cloned;
    }
}
Метод Object.clone() имеет такую сигнатуру:

	protected Object clone()

Заметьте, возвращаемый тип изменён с Object на Covariance. Теперь, к примеру, нет нужды приводить результат работы метода clone() к действительному типу объекта, как это требовалось в ранних версиях JDK. Вместо этого кода:

Covariance foo = new Covariance();
Covariance bar = (Covariance)foo.clone();

Мы можем смело писать код следующий:

Covariance foo = new Covariance();
Covariance bar = foo.clone();



SPRING
329. Шо такое Spring?
«Это какой-то набор библиотек». В принципе отвечающий прав. Но для устройства на работу надо знать, какой именно. В этом небольшом очерке попытаюсь доступно и доходчиво описать, 
что собой представляет контейнер IoC из Spring Core, c которого надо начинать знакомство со Spring.
Принцип Inversion of Control (IoC) гласит: программировать надо на интерфейсах, а не на их реализациях.
Применяя IoC, уменьшается количество изменяемого кода при изменении логики.

330. Аннотации Spring к классам.
В Spring IoC существуют 4 аннотации, которыми помечаются классы:
@Component
@Service
@Controller
@Repository
Все аннотации делают ровно одно и то же, есть разница только в смысле: @Component означает какой-то абстрактный бин, @Service служит для обозначения сервисов, 
@Controller – контроллеров из Spring MVC, @Repository – для обозначения репозиториев или DAO (по Фаулеру репозиторий – это фасад для нескольких DAO, но на практике 
часто вместо написания своей аннотации используют Repository для DAO). Делать 4 аннотации вместо одной имеет смысл ещё потому, что с помощью аспектов из Spring AOP можно обратиться ко всем классам конкретного слоя по аннотации, например, к DAO, чтобы изменить их поведение, например, добавить логирование, специфичное только для слоя DAO.

331. Расскажите об аннотации Autowiring.
@Autowired
private StringedInstrumentMusician stringedInstrumentMusician;
@Autowired(required=false)
Аннотация Autowired означает, что будет произведен поиск среди всех реализаций интерфейса StringedInstrumentMusician, помеченных как @Component (@Service, …), 
и если найден ровно 1 кандидат на wiring, stringedInstrumentMusician будет инициализирован им. Если не найден – будет exception. Указав @Autowired(required=false), 
можно этого exception-а избежать. Если классов будет несколько (как у нас), то тоже будет выкинут exception: надо указать конкретную реализацию:

@Autowired
@Qualifier(“violinist”)
private StringedInstrumentMusician stringedInstrumentMusician;


@Service("violinist") или @Service(name="violinist")


332. Аннотация Scope.
@Service("testBean")
@Scope("singleton")
public class TestBean {
  private String data = "I am a singleton!!";
  
  public String getData() {
    return data;
  }

  public void setData(String data) {
    this.data = data;
  }
}
singleton	только один экземпляр бина создается для IoC контейнера; значение по умолчанию
prototype	создается новый экземпляр бина когда приходит запрос на его создание
request	        один экземпляр бина для каждого HTTP запроса
session	        один экземпляр бина для каждой сессии
global-session	один экземпляр бина для каждой глобальной сессии


333. Другие аннотации Spring.
@Transactional - Перед исполнением метода помеченного данной аннотацией начинается транзакция, после выполнения метода транзакция коммитится, при выбрасывании RuntimeException откатывается.
@Autowired - Аннотация позволяет автоматически установить значение поля.
@RequestMapping - Аннотация используется для маппинга урл-адреса запроса на указанный метод или класс. Можно указывать конкретный HTTP-метод, который будет обрабатываться (GET/POST), передавать параметры запроса.
@ModelAttribute - Аннотация, связывающая параметр метода или возвращаемое значение метода с атрибутом модели, которая будет использоваться при выводе jsp-страницы.
@PathVariable - Аннотация, которая показывает, что параметр метода должен быть связан с переменной из урл-адреса.
@PostConstruct - Аннотация для метода, который будет вызван после вызова конструктора бина.
@PreDestroy - Аннотация для метода, который будет вызван перед уничтожением бина.
@Profile - Аннотация для создания профилей конфигурации проекта. Может применяться как к бинам так и к конфигурационным классам.
@RequestParam(required = false) String uid

334. Аннотация @Resource
Аннотация @Resource
@Resource — аннотация Java EE 5 и Java 6. По действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина. Примеры выше можно переписать вот так:
// @Autowired
// аналогично
@Resource
private TestBean bean;
* This source code was highlighted with Source Code Highlighter.
и
// @Autowired
// @Qualifier("specialTestBean")
@Resource(name="specialTestBean")
private TestBean bean;

